#!/usr/bin/env perl
use strict;
use warnings;
use integer;
use Cwd 'abs_path';
use Pod::Usage;
use Getopt::Long;
use Fcntl qw(:flock SEEK_SET);
use File::Compare;
use File::Copy;
use File::Find;
use File::Path qw(make_path remove_tree);
use File::Spec;
use File::Temp qw();
# use File::Which; # not mandatory but recommended; there are fallbacks
# use Term::ANSIColor; # not mandatory but recommended: fallback to no color
# use IO::Uncompress::Gunzip qw(gunzip); # if not available, flag ?/?? is ignored

$|=1;

my $name = 'squashmount';

sub version {
	print("$name 6.0\n");
	exit(0)
}

=head1 NAME

squashmount - mount certain directories with squashfs + overlayfs/aufs/...

=head1 SYNOPSIS

=over 8

=item B<squashmount> [options] I<command> [I<mask1> I<mask2> ...]

Where I<command> is one of B<mount>, B<umount>, B<remount>, B<set>, B<reset>,
B<status>, B<forget>, B<print->I<...>

=back

To get an extended help, type B<squashmount man>

=head1 DESCRIPTION

For each configured mount-point (resp. if I<mask1>, I<mask2>, ... are given,
for all mount-points whose tag matches at least one of the masks),
the corresponding directory is mounted readonly using squash as a readonly
filesystem and additionally using overlayfs/aufs/... as a writable filesystem.

When the filesystem is umounted or remounted, the changed data is recompressed
(unless the mount-point is configured otherwise).

Normally, your init-system should call B<squashmount start> and
B<squashmount -f stop> on starting or shutdown of your system, respectively,
so that you data is regularly resquashed.
You can manually get this effect of resquashing by calling
B<squashmount remount>.

B<squashmount> reads its mount-points from F</etc/squashmount.pl> which is
documented later (the path can be changed with B<--config>).
Configured directories are created if necessary; squashmount never removes
directories (not even configured temporary directories.)

B<squashmount> keeps its current state in F</run/squashmount> (the path
can be changed with B<--rundir>) in a format which may depend on tools used
and which may also change in future versions of B<squashmount>.
B<squashmount> assumes that its data stored
in F</run/squashmount> and the actually mounted directories coincide, that is,
that they are not mounted/umounted without using B<squashmount> and, in
particular, that you do not reboot without calling B<squashmount stop>
and without cleaning the directory.
Therefore, if you modify F</etc/squashmount.pl> (even more if you
change to a different version of B<squashmount>) you must make sure to
update F</run/squashmount>; see the documentation of the B<stop> and
B<forget> commands.

B<squashmount set> can be used to set/unset certain
temporary states for the matching mount-tags into F</run/squashmount> which
will be honoured during umount, stop, restart, or remount.
For example, combining with B<--no-squash> or B<--kill> you can instruct
B<squashmount> to keep or kill the new data without resquashing when
umounting, remounting, or shutting down.
The set state is kept until B<squashmount stop> or B<squashmount restart> is
executed (or until F</run> is cleaned by the system e.g. on a reboot).
In particular, this state is unchanged by B<squashmount umount>,
B<squashmount mount>, or B<squashmount remount>.
To change the state permanently, modify the definition of the mount-tag in
the configuration file F</etc/squashmount.pl> correspondingly and call
B<squashmount reset> to propagate the modification to the running system.

Each I<command> applies to all configured mount-points
(resp. to those selected by the additional B<mask1> B<mask2> ... arguments).
The following values for I<command> are availabe:

=over 8

=item B<mount>

Mount all configured mount-points.

This works only if the corresponding squash-file already exists.
Use B<start> or B<create> instead if you want to create the squash-file
for the first time.

=item B<umount>

Umount all configured mount-points, resquashing if data was changed
(and has reached a configured threshold).
Moreover, the modified data in the CHANGES directory is removed
(the directory is "cleaned").
This command keeps the local setting made with B<quashmount set>
unless the option B<-r> (B<--reset>) is used.

=item B<remount>

This is somewhat like calling B<umount> followed by B<mount>.
This is skipped if it is neither necessary to resquash nor to delete data
(when skipping also the option B<-r> is ignored.)
Use B<--force> to omit this skipping.

=item B<create>

This is meant to be used only the first time when a mount-point is used:
It creates the squash-file from the directory DIR specified in the
configuration of that mount-point; afterwards that directory is cleaned.
If the squash-file already exists, you have to use B<--force> (and B<--quiet>
if you want to suppress the corresponding warning).

=item B<start>

This is like B<squashmount mount>, but if there is not yet a squash-file
(that is, presumably only the first time when this mount-point is used),
B<squashmount create> is executed in advance.

=item B<stop>

This is like calling B<squashmount umount> followed by B<squashmount forget>:
After umounting it forgets all corresponding information of B<squashmount set>
for the corresponding mount-points, and moreover, if the configuration uses
temporary directories, new directories will be chosen on the next B<mount>.

In order to change F</etc/squashmount.pl> after B<squasmount mount> was called,
the safe way is to call first B<squashmount stop> (at least for the
mount-points you want to modify) and then do your modifications.

If used with B<--force> forget also umounted mountpoints.

=item B<restart>

This is like calling B<squashmount stop> followed by B<squashmount start>.
Note that in contrast to B<remount> this is executed unconditionally
(and it differs also substantially from B<squashmount --force remount>).
If used with B<--force> forget and try to mount umounted mountpoints.

=item B<status> or B<list>

This outputs some general status information, depending on the verbosity level.
To output particular data use the B<print-...> commands (and specify B<mask1>).

=item B<check>

Check whether B<DIR> is empty; usually this should always be the case.
Normally, this command requires that the corresopnding mountpoint is umounted.
Use option B<-f> to force an umount temporarily.
In this case, B<--lazy> always defaults to false unless specified by the option.

B<check> cannote be used if B<DIR> is unknown, that is, if B<DIR> is a defined
by a function which was never called before.
You can use B<squashmount -f print-dir> in advance to force B<DIR> to be known.

=item B<set>

If combined with other options, modify the corresponding active state
of B<--backup>, B<--tempdir>, B<--compression>, B<--threshold>, and B<--kill>
in F</run/squashmount>.

=item B<reset>

Undo all effects of a previous B<set> commands for the corresponding
mount-point, according to the current F</etc/squashmount.pl>.

If you change B<BACKUP>, B<TEMPDIR>, B<COMPRESSION>, B<THRESHOLD>, or B<KILL>
for a mount-point in </etc/squashmount.pl>, use B<squashmount reset> to
activate this new setting.
For other changes on F</etc/squashmount.pl> see the description of the
B<forget> command.

=item B<forget>

This removes B<all> local configuration stored in F</run/squashmount> for
the corresponding mountpoints. It works only for umounted mountpoints.
(You can use F<--force> to make it work anyway, but this is very dangerous;
see below).

In order to change F</etc/squashmount.pl> after B<squasmount mount> was called
(or when changing to a different version of F<squashmount>),
the safe way is to call first B<squashmount stop>, i.e. B<squashmount umount>
followed by B<squasmount forget> (at least for the mount-points you want to
modify) and only then do your modification/upgrade F<squashmount>.

If you shortcut this (e.g. because you forgot calling B<squashmount stop>
in advance or because you cannot umount currently some reason) you have to
know more details: Changes to B<BACKUP>, B<TEMPDIR>, B<COMPRESSION>,
B<THRESHOLD>, or B<KILL> can be made active by using B<squashmount reset>.
(In case of a change of the B<squashmount> version the behavior is not defined.)
With this knowledge you should be able to call B<squashmount stop> even
after you made your changes.

If you plan to use B<forget> with the B<--force> flag on a mounted mount-point,
you must know what you are doing: B<squasmount> is then no longer aware that
the correspondig mount-point is actually mounted; you are then responsible
for umounting these mount-points without using B<squashmount>.

=item B<print-tag>

Output the tag.
This is mainly useful to get a list of all tags if you do not specify a mask.
For usage in scripts, combine this with B<-q>.

=item B<print-dir>

Output the name of the directory B<DIR> of the specified mount-point(s).
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-readonly>

Output the effective B<READONLY> directory.
Output B<1> if the mount-point is configured to be non-writable.
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-changes>

Output the effective B<CHANGES> directory in which the modified data is stored.
The result is undefined if the mount-point is configured to be non-writable.
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-file>

Output the absolute path to the squash-file.
For usage in scripts, combine this with B<-q>/B<-S> and pass a tag.

=item B<print-type>

Output the tool actually used for mounting.
Possible output is C<overlayfs>, C<aufs>, C<unionfs-fuse>, C<unionfs>,
C<funionfs>, C<bind>, or C<readonly>.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-new>

Output 1 if there is new (i.e. modified) data.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-will-squash>

Output 1 if data will be resquashed on the next umount/remount
according to current setting and data.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-threshold>

Output the currently active threshold value.
Every negative value is normalized to B<-1>.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<print-kill>

Output 1 if kill is active.
For usage in scripts, combine this with B<-q> and pass a tag.

=item B<help>

Print a brief help.

=item B<man>

Show an extended help as a manpage.

=back

=head1 OPTIONS

=over 8

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Display extended help as a manpage.

=item B<--verbose> or B<-v> (accumulative)

Verbose output.

=item B<--squash-verbose=>I<level>

Determines how verbose B<mksquashfs> is called.
The following I<level> values are available:

=over 16

=item B<0>:
Redirect stdout of B<mksquashfs> to F</dev/null> and use B<-no-progress>

=item B<1> (or anything else than B<0> and B<2>):
Redirect stdout of B<mksquashfs> to F</dev/null>.
You might want to apply a patch for B<mksquashfs> to redirect the progress bar
to stderr: This produces the nicest output with no redundant information.

=item B<2>:
Call B<mksquashfs> without additional options or redirections.

=back

The default I<level> is user-specified in F</etc/squashmount.pl>;
if not specified there the default is B<1>.

=item B<--quiet> or B<-q> (accumulative)

Quiet output.
Use this with B<check> or B<print-...> if you want to use the output in scripts.
See also B<--separator>.

=item B<--version> or B<-V>

Print version number and exit

=item B<--config>B<=>I<file> or B<-c> I<file> (accumulative)

Using I<file> instead of B</etc/squashmount.pl> as a config file.
If this option is repeated, all passed B<file>s are parsed in the given order.

=item B<--rundir=>I<dir>

Using I<file> instead of B</run/squashmount>.

=item B<--interactice> or B<-i>

Ask for confirmation before cleaning a directory.

=item B<--no-squash> or B<--nosquash> or B<-n>

(This is an alias for B<--threshold=-1>.)
If used with B<umount> or B<remount> do not resquash the directories and
keep the new data.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--squash> or B<-s>

(This is an alias for B<--threshold=0> which is normally the default.)
If used with B<umount> or B<remount> squash the directories if they have
been changed.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--threshold=>I<size> or B<-t> I<size>

For negative I<size> act as described for B<--no-squash>, and for zero I<size>
act as described for B<--squash>.

For positive I<size>, if the length of the changes is less than I<size> bytes,
squashmount will act with B<umount> as if B<--no-squash> is active, otherwise
it acts normally, that is, the data is resquashed.

For convenience, you can append B<k>, B<m>, B<g>, B<t> to the number to denote
kilobytes (1024), megabytes (1024^2), gigabytes (1024^3),
or terrabytes (1024^4), respectively.

For the particular case that I<size> is empty the value of the current
F</etc/squashmount.pl> is taken (cf. the B<unset> command).
This is useful B<set> has been used:

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--kill> or B<-k>

When umounting/remounting do not resquash the data but delete all new data.
Use with care!
For safety reasons, this has no effect if the currently active B<--threshold>
values is negative.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--no-kill> or B<--nokill> or B<-K>

Remove the effect of B<--kill>.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--backup>B<=>I<file_or_appendix> or B<-b> I<file_or_appendix>

Override the value of B<BACKUP> for all specified mount-points.
If nonempty and not an absolute path, the effective value is the current value
of B<FILE> with the string C<appendix> appended.
The empty value means no backup.
For obvious reasons you should better not give an absolute path if
using several mount-points.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--no-backup> B<--nobackup> or B<-B>

This is equivalent to specifying B<--backup> with an empty argument:
For all specified mount-point no backup is made.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--tempdir>B<=>I<tempdir> or B<-D> I<tempdir>

Override the value of B<TEMPDIR> for all specified mount-points.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--compression>B<=>I<mode> B<--comp>B<=>I<mode> or B<-x> I<mode>

Override the value of B<COMPRESSION> for all specified mount-points.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if mount-point was correspondingly
configured (without actually changing the configuration, of course).

=item B<--reset> or B<-r>

After umounting, reset the data changed with the B<set> command according
to the current configuration in F</etc/squashmount.pl>

=item B<--force> or B<-f>

If used with B<remount> do not skip remounting, even if it is not
necessary to resquash or to delete data.

If used with B<create>, continue even if the squash-file already exists.

If used with B<check>, force temporary umounting.

If used with B<stop> or B<restart>, forget information also for
umounted mountpoints.

If used with B<forget>, forget information also if mountpoint is mounted.
The latter is very dangerous, see the description of the B<forget> command.

If used with B<print-...> or B<status>, when required to print directories
corresponding to temporary names not created yet, they will be created and
their names fixed for future mounting (until B<forgot> is used).

=item B<--ignore-state> or B<-I>

Whenever umounting, try to umount even mount-points which are apparently
umounted according to the setting in F</run/squashmount>.
If combined with B<-f> also try to umount B<READONLY> even if
umounting of B<DIR> failed.

Similarly, whenever mounting, try to mount even if apparently already
mounted according to the setting in F</run/squashmount>.
If combined with B<-f> proceed even if mounting of B<READONLY> seems to fail.

This option should only be necessary in exceptional caseas like bugs in
B<squashmount> or F</etc/squashmount.pl> or if you manually interfered
or removed or corrupted F</run/squashmount>.
In this case, the best attempt is to call
C<squashmount -fI umount> or C<squashmount -nfI umount> for trying to force
umounting unconditionally all configured directories.

=item B<--lazy>

When umounting fails, attempt also lazy umounting.

=item B<--no-lazy> or B<--nolazy>

Do not attempt lazy umounting when normal umounting failed.
Whether B<--lazy> or B<--no-lazy> is the default depends on F</etc/squashmount.pl>;
if not specified there the default is B<--lazy>.

=item B<--locking>

Use perl's flock() to avoid simulatenous usage of the same mount-point.

=item B<--no-locking> or B<--nolocking>

This is the opposite of B<--locking>.
Whether B<--locking> or B<--no-locking> is the default depends on the
variable B<$locking> in F</etc/squashmount.pl> (the default in the latter
is true except if some of the commands B<status> or B<print-*> is used.)

=item B<--threshold=>I<size> or B<-t> I<size>

This is analogous to B<--no-squash> but will avoid the resquashing only if
there is less that I<size> bytes changed on disk.
(You can append B<k> or B<m> to I<size> to denote multiples of 1024 or 1024^2,
respectively.)
A negative number is equivalent to B<--no-squash>.
If I<size> is empty the value configured from F</etc/squashmount.pl> is taken.

=item B<--separator=>I<sep> or B<-S> I<sep>

When using B<check> or B<print-...> with option B<-q>,
I<sep> is appended to the output of each mountpoint.
The default is a newline.

=item B<--pass-dir>

When this option is used, the passed arguments I<mask1> I<mask2> ... are
interpreteted as names of mounted readonly or writable directories.
This is to allow this script to be used as a callback from umount-wrappers
like /sbin/umount.overlayfs or /sbin/umount.squashfs

=item B<--color> or B<-F>

Try to color even if output is not a terminal.

=item B<--no-color> or B<--nocolor> or B<-C>

Do not color the output.
Setting the environment variable B<ANSI_COLORS_DISABLED> has the same effect.

=item B<--no-star> or B<-nostar>

Omit printing C< * > at beginning of messages.

=item B<--star>

Print C< * > at beginning of messages.
This is currently the default, but this might change in future versions
of squashmount, at least for certain commands.

=item B<--title=>I<options> or B<-T> I<options>

The corresponding I<options> are passed to the title script to set the
hardstatus title. This option can be used accumulatively.
If at least one passed option is B<->, the title script is not used.

=item B<--error> or B<-e>

Do not process further mount-points when an error occurs.

=item B<--no-error> or B<--noerror> or B<-E>

Do not break on non-fatal errors but try to process all (matching) mount-points
if there is a chance to do so. This is the default.

=item B<--fatal>

Return nonzero exit status only on fatal errors.
In particular, the status will be zero even if the (u)mounting of some
mount-points failed.

This is the default with the commands B<start>, B<stop>, or B<restart>, because
this is probably  the appropriate behaviour if called from an initsystem.
For all other commands the default is:

=item B<--no-fatal> or  B<--nofatal>

Return nonzero exit status if the handling of at least one mount-point
produced an error.
This is the default except for the commands B<start>, B<stop>, or B<restart>,
see above

=item B<--first> or B<-1>

Only execute the first match, then end.

=item B<-->

Last option

=back

=head1 F</etc/squashmount.pl>

The file F</etc/squashmount.pl> can be any perl code which fills
the array B<@mounts> with references to hashes; one hash for every tag.
In addition, the array B<@order> can be filled with the available tools,
the order in which they should be tried, and flags whether modprobe should
be called, how to test the existence of tools and what to do if tools appear
unavailable.
Also the default variables B<$lazy>, B<$squash_verbose>, B<$locking>,
and B<$modprobe_squash> can be initialized: They are initialized to B<1>
(perl interprets this as I<true>) or B<''> (I<false>).

Here is an example for this file.
(You can use this syntax if you do not have much knowledge about perl;
if you know more about perl, a more convenient syntax is recommended,
see the remarks at the end of this manpage.)

=over 8

=item $lazy = 1; # unnecessary; this is the default

=item $nosquash = '/etc/killpower'; # ignore /etc/nosquash

=item $squash_verbose = 1; # unnecessary; this is the default

=item $locking = 1; # lock always, even for status and print-* commands

=item $modprobe_squash = ''; # Differ from default: No modprobe squashfs

=item @order = qw(overlayfs? aufs! unionfs-fuse! unionfs??# funionfs??#);

=item # The main task is to set B<@mounts>. Use one of

=item # @mounts = ( { ... }, { ...} );

=item # push(@mounts, { ... }, { ... });

=item # (The latter can be used successsively to append mount-points...)

=item @mounts = ( {

=over 16

=item TAG => 'useless_minimal',

=item DIR => '/usr/local',

=item FILE => '/usr/local.sqfs',

=back

=item }, {

=over 16

=item TAG => 'guest',

=item DIR => '/home/guest'

=item FILE => '/home/guest-skelton.sqfs'

=item CHMOD => 0200, # squashfile readonly by user

=item CHOWN => [ (getpwnam('guest'))[2], 1000 ], # uid/gid

=item # CHOWN => '2000:1000' would also be possible

=item KILL => 1 # Forget all changes when umounting

=back

=item }, {

=over 16

=item TAG => 'tex',

=item DIR => '/usr/share/texmf-dist',

=item FILE => '/usr/share/texmf-dist.sqfs',

=item CHANGES => '/usr/share/texmf-dist.changes',

=item READONLY => '/use/share/texmf-dist.readonly',

=item DIFF => [ qr{^ls-R$},

=item qr{^tex(/generic(/config(/language(\.(dat(\.lua)?|def)))?)?)?$} ]

=back

=item }, {

=over 16

=item TAG => 'portage',

=item DIR => '/usr/portage,

=item FILE => '/usr/portage.sqfs',

=item CHANGES => '/usr/portage.changes',

=item READONLY => '/usr/portage.readonly',

=item THRESHOLD => '40m', # resquash on umount if 40 MB changed, or

=item # if local/* (with * not .git, profiles, metadata) changed:

=item FILL => qr{^local/(?!(\.git|profiles|metadata)(/|$))}

=back

=item }, {

=over 16

=item TAG => 'fancy_temporary',

=item DIR => sub { return File::Temp::newdir() },

=item CHANGES => sub { return File::Temp::newdir(undef, DIR => '/path/to/ramdisk') },

=item READONLY => \&make_temporary_subdir,

=item FILE => '/just/a/crazy/example.sqfs',

=item SKIP => '^\.', # A string is also possible

=item SKIPDIR => qr{(^|/)tmp}i, # tmp* Tmp* TMP*

=item SKIPFUNC => sub { my ($rel, $abs, $ro) = @_; return (-d $abs) }

=back

=item });

=item sub make_temporary_subdir { my ($tag) = @_;

=over 16

=item my $dir = File::Temp::newdir(undef, CLEANUP => '')->dirname;

=item # CLEANUP => '' is crucial since we return only a string!

=item $dir .= "/$tag"; mkdir($dir); return $dir }

=back

=back

Except for B<@mounts>, the meaning of the variables is easily explained:

=over 8

=item B<$lazy>

This determines whether B<--lazy> or B<--no-lazy> is the default.
This variable defaults to the value B<1> (I<true>).

=item B<$killpower>

This is a string or a reference to an array of strings.
If one of the strings is an existing file, then B<squashmount> behaves as
if option B<--no-squash> has been passed.
The default value is the array reference
B<[ '/etc/killpower', '/etc/nosquash' ]>.
The explanation for this default follows.

The file F</etc/killpower> is generated by tools like B<nut>.
Consequently, by default, B<squashmount> will not try to resquash any data
when it is on an emergency shutdown caused by such a tool.

The file F</etc/nosquash> may be generated by you if you know that
you will reboot often (e.g. to test new kernels) and if you do not want to
resquash the data just for rebooting.
Note that for a single reboot, it is more convenient to call
B<squashmount -n set> instead, but this effect is gone after the reboot:
when one makes changes to the system which require a series of reboots
(e.g. tracking a bug in the kernel), it is easy to forget to call
this command before every single rebooting which can be quite annoying.
Therefore the file F</etc/nosquash> can be generated to keep this information
across reboots; of course, one should not forget to remove this file once
the series of reboots is finished.

=item B<$squash_verbose>

This is the default if B<--squash-verbose> is not specified.
This variable defaults to the value B<1> (I<true>).

=item B<$locking>

This determines whether B<--locking> or B<--no-locking> is the default.
This variable defaults to the value B<''> (I<false>) when the commands
B<status> or B<print-*> are used; for all other commands it defaults to
B<1> (I<true>).

=item B<$modprobe_squash>

This determines whether C<modprobe squashfs> is executed before the first
squashfile is mounted.
This variable defaults to the value B<1> (I<true>).

=item B<@order>

This array determines in which order the overlayfs/aufs/... tools are tried
and/or whether it is attempted to modprobe them and on which conditions they
are (tacitly) skipped.

The first successful tool is chosen, and if all fail, B<mount --bind> is used.
The content of this array should be strings with one of the texts

=over 16

=item B<overlayfs>, B<aufs>, B<unionfs-fuse>, B<unionfs>, B<funionfs>

=back

for the corresponding tool. By default, it is attempted to B<modprobe> the
corresponding module, and if that B<modprobe> fails, the corresponding tool
is tacitly skipped. Optionally, you can append or prepend the following
special flags to change this default behaviour:

=over 16

=item B<!> or B<!!>

If this flag is used, a failure in the modprobe command is ignored;
in case of B<!!> the modprobe is not even attempted.
In particular you should use this if it might happen (or you know) that the
corresponding tool is compiled directly into the kernel.
Note that B<overlayfs>, B<aufs>, B<unionfs> have their own kernel modules
while B<unionfs-fuse> and B<funionfs> both require the B<fuse> module and
need special userspace binaries.

=item B<?> or B<??>

If this flag is used and the B<modprobe> failed (or if combined with B<!!>)
the content of B</proc/config.gz> is checked for whether the corresponding tool
appears available in the running linux kernel.
If the tool appears unavailable it is tacitly skipped.
For the case that B</proc/config.gz> cannot be read and the B<??> variant
is used, the tool is considered as unavailable.
Usage of this flag requires that the perl module B<IO::Uncompress::Gunzip>
is available; the flag is tacitly ignored if this is not the case

=item B<#>

If this flag is used, it is checked whether the binary
(B<mount> in case of B<overlayfs>, B<aufs>, or B<unionfs> or the special
userspace binary for B<unionfs-fuse> or B<funionfs>, respectively)
is available in your path. If it is unavailable, the tool is
tacitly skipped. This flag is ignored if neither B<File::Which> nor the
B<which> program are available.

=back

If B<squashmount> is used with a command for which the order is possibly needed
(B<start>, B<restart>, B<mount>, B<remount>), this array defaults to

=over 16

=item B<qw(overlayfs!? aufs! unionfs-fuse! unionfs! funionfs!)>

=back

This means that all modules are loaded as required with overlayfs being
tacitly skipped if the running kernel does not provide support for it;
all other tools are attempted in the order until the first succeeds,
no matter whether the kernel provides support for it.

If B<squashmount> is used with a different command, the default of this
array is empty.

=back

The array B<@mounts> defines the various mount-points.
The first mount-point in the above example is the minimal data which
has to be specified for a mount-point.
However, typically you should also specify at least the keys B<CHANGES> and
usually also B<READONLY> unless you have a special reason not to.
The following keys are supported. If a key is undefined or not explicitly set,
a default value is chosen in some cases.

=over 8

=item B<TAG>

A unique identifier:
The B<TAG> is matched against the I<mask> entries on the command line.
The content must be alphanumeric; only the symbols B<.> B<-> B<_> are allowed.

=item B<DIR>

The absolute path of the main directory which you want to squash.

Alternatively, B<DIR> can be a functin reference which returns a string to
the directory or alternatively a B<File::Temp::Dir> object.
This function is executed only once if B<DIR> is unknown and in this case
it gets passed the tag as an argument.
The intention is that this function can be used to return e.g. a temporary
dirname by using something like as in the B<fancy_temporary> example above.

Be aware that if this function uses B<File::Temp::newdir>, it should pass
B<CLEANUP =E<gt> ''> to avoid that the directory is magically removed recursively:
Forgetting this can severly damage your data!

As an exception, if the function returns the corresponding created object
(and not only a filename as in the B<make_temporary_subdir> example above),
B<squashmount> will care about disabling B<CLEANUP> automatically.
For this reason, we had lazily avoided B<CLEANUP =E<gt> ''> in some places
in the above B<fancy_temporary> example when calling B<File::Temp::newdir>.

If you use a temporary directory, you can find the actual used path with
B<squashmount print-dir ...>

=item B<FILE>

The absolute path to the squash-file which contains the actual data.

=item B<CHANGES>

The directory into which the changes to B<DIR> are stored.
If B<CHANGES> is not specified then a temporary directory is created
and used instead.

The same rules as for B<DIR> hold, that is, you can also pass a function which
explicitly calls B<File::Temp::newdir> with appropriate data.

Note that using a temporary directory may be dangerous since if temporary
directories are cleaned on boot this means that modifications to B<DIR>
are lost if they are not (successfully) squashed on shutdown
(e.g. due to option B<--no-squash>).
If you use a temporary directory, you can find the actual path with
B<squashmount print-changes ...>

=item B<READONLY>

If this is nonempty but not an absolute path, then B<DIR> is mounted readonly.
If this is an absolute path then a readonly version of the content of B<DIR>
is mounted here.
It is not possible to omit this directory if B<DIR> should be writable.
For the special case that B<READONLY> is empty, a temporary directy is used.

The same rules as for B<DIR> hold, that is, you can also pass a function which
explicitly calls File::Temp::newdir with appropriate data.

If you use a temporary directory, you can find the actual path with
B<squashmount print-readonly ...>

=item B<THRESHOLD>

This is the threshold value used for that mount-point
(unless changed by command line options).
Set it to a negtive value for an infinite threshold,
that is, to get the effect of B<--no-squash>.
The default is B<0>.

=item B<KILL>

If true (nonempty and not 0) B<--kill> is active for that mount-point
(unless changed by command line options).

=item B<MKSQUASHFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when calling B<mksquashfs>.
The option B<-noappend> is used automatically.
Depending on B<$squashfs_verbose>, B<COMPRESSION>, B<DEFAULT_FRAGMENTS>
also the options B<-no-progress>, B<-comp>, or B<-always-use-fragments>
are appended automatically.

=item B<MKSQUASHFS>, B<COMPOPT_{XZ,LZMA,GZIP,LZO,LZ4,}

These should be a (possibly empty) strings or references arrays of strings:
These strings are used as additional options when calling B<mksquashfs>
(the latter only if the corresponding B<COMPRESSION> option is used;
B<COMPOPT_> is used if B<COMPRESSION> is empty.)
The option B<-noappend> is used automatically.
Depending on B<$squashfs_verbose>, B<COMPRESSION>, B<DEFAULT_FRAGMENTS>
also the options B<-no-progress>, B<-comp>, or B<-always-use-fragments>
are appended automatically.
If the corresponding variable is not defined, it is assumed to be empty
with the following exception:

=over 16

=item B<COMPOPT_LZ4>: If undefined, defaults to C<'-Xhc'>.
Set it to the empty string if you want fastest B<lz4> compression instead.

=back

=item B<MOUNT_OVERLAYFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with overlayfs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_AUFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with aufs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_UNIONFS_FUSE>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with unionfs-fuse.
The default is B<['-o', 'cow', '-o', 'allow_other', '-o', 'use_ino',
'-o', 'nonempty', '-o', 'noatime', '-o', 'hide_meta_files']>.

=item B<MOUNT_UNIONFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with unionfs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_FUNIONFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with funionfs.
The default is B<['-o', 'allow_other', '-o', 'nonempty']>.

=item B<COMPRESSION>

Specifies the compression mode for B<mksquashfs>:
The available values depend on the installed version of B<mksquashfs>;
typically B<xz>, B<lzma>, B<gzip>, B<lzo>, B<lz4> are available
(ordered in increasing compression ratio, i.e. B<xz> is usually the slowest but
best in compression ration while B<lz4> is the quickest).
If the value is empty, no B<-comp> parameter is passed,
that is, the default of the installed B<mksquashfs> is chosen
(which is usually B<gzip> but might depend on your version of B<mksquashfs>).
The default of B<COMPRESSION> (that is, if undefined or not explicitly set)
is B<lz4>; not that in earlier versions of B<squashmount> this was B<xz>.

=item B<DEFAULT_FRAGMENTS>

Unless this variable is a nonempty string,
B<-always-use-fragments> is appended to the options of B<mksquashfs>
which usually improves the compression ratio.
You might need to set this variable (at the cost of slightly worse results)
if you need compatibility with older versions of B<squashfs>.

=item B<BACKUP>

If this is set to an absolute path, then when resquashing B<FILE>,
a copy of the old version is moved to that path.
If the file B<BACKUP> already exists, it is removed.

If B<BACKUP> is not an absolute path but nonempty, the path is that of
B<FILE> with the value of B<BACKUP> appended.
If B<BACKUP> is empty, no backup is made.

=item B<CHMOD>

If defined and nonempty this should be a number (if you want an octal number,
do not enclose into quotes and start with a leading B<0>, or otherwise
use perl's B<oct(>I<decimal number>B<)> function).
The number defines the mode to which the squashfile is changed with B<chmod>
whenever it is created.
The empty string means that the mode remains B<0400>.
If undefined (the default), the mode B<0644> is taken.

=item B<CHOWN>

If defined and nonempty this should be either an array reference B<[> I<uid>B<,> I<gid> B<]>
or a string of the form I<uid>B<:>I<gid>; in this case, the user/group id of
the file is changed to I<uid>/I<gid>, resepectively.
Use the undefined or empty value or B<-1> to indicate that I<uid>/I<gid>
should not be changed (typically remains B<0>).
If you want to pass the user or group name (instead of the user or group id),
you can use e.g. the perl construct B<(getpwnam('>I<username>B<'))[2]> or
B<(getgrnam('>I<groupname>B<'))[2]>, respectively.

=item B<TEMPDIR>

The new version of the squashed data is first created in a temporary file.
If B<TEMPDIR> is set it is created in this directory.
It is useful to choose a directory on a harddisk if the regular temporary
directory is a ramdisk with less space than the expected filesize.
If you choose a harddisk, things will be faster if you choose the same
partition on which the squash-file B<FILE> resides.

=item B<BLOCKSIZE>

The size of one disk-block when calculating the changed data for the threshold.
The default is 4096.
The blocksize does not have to be in relation with the physical blocksize.
For instance, if you a directory with small files, it might be a good idea
to set B<BLOCKSIZE> to a huge value so that the calculation for the
threshold is essentially based on the number of files (instead of their size).

=item B<SKIP>

This is a regular expression (or a string representing a regular expression)
or a reference to an array of such regular expressions/string.
For each file/directory in B<CHANGES> (except F<.> and F<..> directories)
its path (relative to B<CHANGES>) is matched against these regular expressions.
If the file matches, it is not considered as being changed.
This is useful to avoid squashing only because e.g. a known temporary
file has changed in this directory which you do not care about.

When all changes are skipped during umounting, the B<CHANGES> directory is
cleaned anyway, i.e. skipping a file means that changes to this file are
usually lost (unless the directory is ressquashed anyway).

If a file you want to skip resides in a subdirectory (not in the root
of B<CHANGES>) you probably also want to skip all parent directories,
because overlayfs/aufs/... has to create them to create the file.
However, to be more careful you might want skip them with B<DIFF>
(as that will check that it is really a directory and exists in B<READONLY>).

=item B<SKIPDIR>

This is similar to B<SKIP>, but only for directories; moreover, also the
whole content of matching directories is being considered as unchanged.

If you want to B<SKIPDIR> a directory lying not in the root, of B<CHANGES>
you will probably want to include its parent directories to B<DIFF>
(or to B<SKIP> if you are less careful).

=item B<DIFF>

This is similar to B<SKIP>, but a little bit more careful:
The file/directory is only considered unchanged if it is the same as the
corresponding file in the B<READONLY> directory, up to possibly
permissions or time stamps.
This is to avoid resquashing just because some timestamps or permissions
were changed.

As for B<SKIP> and B<SKIPDIR>, for files in subdirectories you will probably
also want to include the parent directories here.
As an example, to ignore changes only in timestamps or permissions of
the files

=over 16

=item F<tex/generic/config/language.dat>

=item F<tex/generic/config/language.dat.lua>

=item F<tex/generic/config/language.def>

=back

you must also ignore that the corresponding parends are created in CHANGES.
Therefore, in the example file above (in TAG tex), the regular expression
in B<DIFF> not only matches the above files but also their parent directories.

To match for files, it might be convenient to use several regular expressions
(or strings): All related variables B<SKIP>, B<SKIPDIR>, B<DIFF> accept also
references to arrays of regular expressions. See e.g. B<SKIPDIR> in
in the fancy_temporary example above.
Note in that example also that you can can pass regular expressions
instead of strings. This way you can pass e.g. perl flags to ignore case.

=item B<SKIPFUNC>

This is the most generic form of B<SKIP>, B<SKIPDIR>, B<DIFF>:
This is a reference to a function which can decide whether the file is being
considered as changed.
The function gets passed three parameters: The relative filename,
the absolute filename, and the corresponding pathname in the READONLY directory.
The function must return a true value (e.g. 1) if the file should not be
considered as changed.
If the function sets B<$File::Find::prune = 1> in case of a directory
then its content is not considered as changed, either.

In the above B<fancy_temporary> example, this functions is used to ignore all
added/modified (empty) directories.

=item B<FILL>

This is similar to B<SKIP>, but with the opposite meaning:
If there is a matching file/directory then any positive value of
B<THRESHOLD> is considered as reached by the corresponding data.
If B<SKIP>, B<SKIPDIR>, B<DIFF>, or B<SKIPFUNC> apply also, these
take precedence over B<FILL> or B<FILLFUNC>.

=item B<FILLFUNC>

This is the analogue of B<SKIPFUNC>, but corresponding to B<FILL> instead of B<SKIP>.
If the function returns a true value (e.g. 1) the threshold is considered as filled.
This function has no need to modify B<$File::Find::prune>.

=back

It is intentional that F</etc/squashmount.pl> is ordinary perl code so that
you can use all sort of perl features if you like.

Here are some examples why this might be useful:

=over 8

=item B<(1)> You can source other config files/directories at your discretion.

=item B<(2)> You can even interpret other config files in a format you prefer.

=item B<(3)> You can make setups based on the existence of symlinks or dirs.

=item B<(4)> You can use more complex code to setup B<@order>.

=item B<(5)> You can use various shortcuts to setup "standard" mount-points.

=item B<(6)> You can define some keys as "defaults" for all mount-points.

=back

In any case, it is recommended to not use B<too> much code since the code
will be parsed/executed with every call of B<squashmount>.
In particular, if you want some more complex code to setup B<@order> according
to you system, it is recommended to enclose this code into C<if(@order)> so
that this code is only executed if the value of B<@order> is really needed
(recall that the default of B<@order> is nonempty only if B<squashmount> is
used with a command for which it might be necessary to know its value.)

To use some of the mentioned features you need some perl knowledge, of course.
However, others are easy to use even without deep perl knowledge.
In particular, concerning B<(5)> and B<(6)>, B<squashmount> provides two
functions which make this task relatively easy:

=over 8

=item B<standard_mount(>I<tag>B<,> I<dir> I<...>B<)>

This function returns a reference to a hash with the keys B<TAG> and B<DIR>
filled according to the first two arguments.
In addition, the values for the keys B<CHANGES>, B<READONLY>, and B<FILE>
are generated by just appending C<.changes>, C<.readonly>, C<.sqfs> to I<dir>.
Moreover, if I<...> are references to hashes, they are added to the hash:
Later hashes override earlier ones; setting a value to C<undef> in a sense
cancels a previous definition.

=item B<added_hash(>I<hash_reference>B<,> I<hash_reference>B<,> ...B<)>

This function returns a reference to a hash which merges all passed hashes,
that is, it is like B<standard_mount()> except that it does not fill a
hash with certain values first.
The idea is that this function can be used to start with a "default" hash
and override/modify/add some data at your descretion.

For perl specialists: This function is practically the same as that provided
by B<Hash::Merge::Simple>, but it does not require the existence of that
perl module, and it does not work recursively.

=back

Here is an example how to use this to specify the portage mount-point from
the above example and additionally a "standard" mount-point (analogously
to the portage mount-point but with different paths and without the
B<THRESHOLD> option) in a shorter way:

=over 8

=item push(@mounts,

=over 16

=item standard_mount('portage, '/usr/portage', {

=over 24

=item THRESHOLD => '40m'

=back

=item }),

=item standard_mount('kernel', '/usr/src')

=back

=item );

=back

It is recommended to use a perl variable like B<$defaults> to contain
a reference to a hash with data which you want to specify for practically
every mount-point like B<COMPRESSION> or B<TEMPDIR> and to add this
variable to every point-mount.
This way you can easily change the defaults without manipulating every
mount-point entry manually. (You can still override $defaults
for particular mount-points at your discretion.)
Here is such an example which also demonstrates the use of B<added_hash()>:

=over 8

=item my $tempdir = { TEMPDIR => '/my/ramdisk' };

=item my $always = { COMPRESSION => 'gzip', THRESHOLD => '20m' };

=item my $defaults =  added_hash($always, { BACKUP => '.bak' }, $tempdir);

=item push(@mounts,

=over 16

=item standard_mount('portage', '/usr/portage', $defaults),

=item standard_mount('kernel', '/usr/src', $defaults),

=item standard_mount('games', '/usr/share/games', $defaults, {

=over 24

=item READONLY => undef # cancel standard definition

=back

=item })

=back

=item );

=back

=head1 COPYRIGHT AND LICENSE

Copyright Martin VE<auml>th.
This program is under the BSD License.

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Special paths:

my $root = File::Spec->rootdir();
my $devnull = File::Spec->devnull();

# Default for the Options:

my @title = ();
my $verbose = 0;
my $quiet = 0;
my $squash_verbose = undef;
my $opt_color = undef;
my $star = undef;
my $lazy = undef;
my $locking = undef;
my $force = '';
my $ignore_state = '';
my $reset = '';
my $interactive = '';
my $opt_threshold = '';
my $opt_kill = undef;
my $opt_backup = undef;
my $opt_tempdir = undef;
my $opt_compression = undef;
my $pass_dir = '';
my $errorbreak = '';
my $fatalreturn = undef;
my $firstmatch = '';
my @configs = ();
my $separator = "\n";
my $rundir = File::Spec->catdir($root, 'run', 'squashmount');
my $titleopt;

# Paths to executables:

my $title = undef;
my $funionfs = undef;
my $unionfs_fuse = undef;
my $mksquashfs = undef;
my $mount = undef;
my $umount = undef;
my $modprobe = undef;

# Global/State variables:

my $run_ro;             # handle /run/squashmount as readonly
my $modprobe_squash;    # will modprobe squash
my $lockfh = undef;
my $stdoutterm = (-t STDOUT);
my $stderrterm = undef;
my $exitstatus = 0;
my $had_error = '';
my $current = undef;    # current configuration in /run/squashmount
my $current_empty;      # if defined and equal to $current, will remove file
my $user_config = undef;# current configuration in /etc/squashmount.pl
my $tag = '';           # $user_config->{'TAG'}
my $printed_title = ''; # Have we printed a statusline?
my $taglen;             # Length of the longest tag
my $threshold;          # currently active threshold (integer)
my $kill;               # currently active kill (boolean)
my $backup;             # currently active backup (string)
my $tempdir;            # currently active tempdir (string)
my $compression;        # currently active compression (string)

#
# Commands
#

sub cmd_mount {
	return &mount_main('')
}

sub cmd_umount {
	return '' if(&error_unless_mounted());
	return &umount_main()
}

sub cmd_remount {
	return '' if(&error_unless_mounted());
	my ($will_squash, $will_remove) = (1);
	($will_squash, $will_remove) = &check_squash($threshold, $kill)
		if(&is_nonempty($current->{'TYPE'}));
	unless($force || $will_squash || ($will_remove > 0)) {
		&info('remounting appears unnecessary');
		return 1
	}
	&title("$tag remount") if($printed_title);
	return '' unless(&umount_main($will_squash, $will_remove));
	return &mount_main('');
}

sub cmd_create {
	return '' if(&error_if_mounted());
	my $squashfile = &get_abspath('FILE', 1);
	if(-f $squashfile) {
		if($force) {
			&warning("squashfile $squashfile already exists") unless($quiet);
		} else {
			&error("squashfile $squashfile already exists");
			return ''
		}
	}
	return '' unless(&create_dir('DIR', 1));
	return(&first_create($squashfile, $current->{'DIR'}))
}

sub cmd_start {
	return &mount_main(1)
}

sub cmd_stop {
	if(&error_unless_mounted()) {
		&forget_settings() if($force);
		return ''
	}
	return '' unless(&umount_main());
	&forget_settings();
	return 1
}

sub cmd_restart {
	my $ret;
	if(&error_unless_mounted()) {
		return '' unless($force);
		$ret = ''
	} else {
		return '' unless(&umount_main());
		$ret = 1
	}
	&forget_settings();
	return (&mount_main(1) && $ret);
}

sub cmd_forget {
	unless($force || !&is_nonempty($current->{'TYPE'})) {
		&error('mounted, forget is not used');
		return ''
	}
	&forget_settings();
	return 1
}

sub cmd_set {
	$current->{'BACKUP'} = $backup;
	$current->{'TEMPDIR'} = $tempdir;
	$current->{'COMPRESSION'} = $compression;
	$current->{'THRESHOLD'} = $threshold;
	$current->{'KILL'} = $kill;
	return 1
}

sub cmd_reset {
	return &reset_main(!$quiet)
}

sub cmd_check {
	my $dir = &get_abspath('DIR');
	unless(&is_abspath($dir)) {
		&error("DIR is not known yet; use first: $name -f print-dir");
		return 1
	}
	my $mounted = &is_nonempty($current->{'TYPE'});
	if($mounted) {
		unless($force) {
			&error('DIR is mounted. Use -f to umount temporarily');
			return 1
		}
		&info('umounting...') unless($quiet);
		return '' unless(&umount_dir($dir));
		delete($current->{'TYPE'})
	}
	my $status = &dir_is_empty($dir);
	if($status eq '') {
		if($quiet) {
			&do_print('nonempty')
		} else {
			&error('DIR is nonempty!')
		}
	} elsif($status) {
		&do_print($quiet ? '' : 'DIR is empty');
	} else {
		if($quiet) {
			&do_print(undef)
		} else {
			&error("cannot open $dir")
		}
		$status = ''
	}
	return '' if($mounted && !&mount_main('', 1));
	return $status;
}

sub cmd_status {
	my @status = ( &human_type() );
	if(&is_resquash_type()) {
		my $human = &human_threshold($threshold);
		$status[0] .= (' ' x (5 - length($human))) . "(${human})" unless($verbose);
		my ($newdata, undef) = &check_squash($kill ? 0 : $threshold, '');
		if($newdata) {
			push(@status, $kill ?
				'will kill modifications' :
				'will resquash modifications')
		} elsif($kill) {
			push(@status,
				'will kill, but yet unmodified')
		} else {
			my ($nonempty, undef) = &check_squash(0, '');
			push(@status, $nonempty ?
				'modified, but will not resquash' :
				'unmodified')
		}
		push(@status, 'THRESHOLD: ' .
			(($verbose > 1) ? "$threshold" : $human)) if($verbose)
	}
	return &print_status(\@status) unless($verbose > 1);
	my $dir = &get_abspath('DIR', $force, 1);
	push(@status, 'DIR: ' . $dir) if(&is_abspath($dir));
	my $readonly = &get_abspath('READONLY', $force, '');
	push(@status, 'READONLY: ' . $readonly) if(&is_nonempty($readonly));
	push(@status, 'CHANGES: ' . &get_abspath('CHANGES', $force, 1))
		unless(&is_valid_changes($force));
	my $file = &get_abspath('FILE', $force);
	push(@status, 'FILE: ' . $file) if(&is_abspath($file));
	push(@status, "TEMPDIR: $tempdir") if(&is_abspath($tempdir));
	push(@status, "BACKUP: $backup") if(&is_nonempty($backup));
	&mksquashfs_options(\my @options);
	push(@status, "mksquashfs options: " . &join_quoted(@options));
	my $chmod = &get_chmod();
	push(@status, 'CHMOD: ' . (($chmod eq '') ? 'unchanged (0400)' :
		sprintf('%#o', $chmod)));
	my ($uid, $gid) = &get_chown();
	push(@status, 'CHOWN: ' .
		(defined($uid) ? "$uid:$gid" : 'unchanged (0:0)'));
	return &print_status(\@status)
}

sub cmd_print_tag {
	return &do_print($tag)
}

sub cmd_print_dir {
	return &do_print(&get_abspath('DIR', $force, 1))
}

sub cmd_print_readonly {
	return &do_print(&get_abspath('READONLY', $force, ''))
}

sub cmd_print_changes {
	return &do_print(undef) unless(&is_valid_changes($force));
	return &do_print(&get_abspath('CHANGES', $force, 1))
}

sub cmd_print_file {
	return &do_print(&get_abspath('FILE', $force))
}

sub cmd_print_type {
	return &do_print(&human_type())
}

sub cmd_print_new {
	return &do_print(undef) unless(&is_valid_changes($force));
	my ($will_squash, undef) = &check_squash(0, '');
	my $result = $will_squash ? '1' : '';
	return &do_print($quiet ? $result : ('NEW: ' . $result))
}

sub cmd_print_will_squash {
	return &do_print(undef) unless(&is_valid_changes($force));
	my ($will_squash, undef) = &check_squash($threshold, $kill);
	my $result = $will_squash ? '1' : '';
	return &do_print($quiet ? $result : ('WILL_SQUASH: ' . $result))
}

sub cmd_print_threshold {
	return &do_print(($verbose || $quiet) ?
		"$threshold" : &human_threshold($threshold))
}

sub cmd_print_kill {
	my $result = $kill ? '1' : '';
	return &do_print($quiet ? $result : ('KILL: ' . $result));
}

#
# Functions
#

# The main start/mount function:

sub mount_main {
	my ($first_create, $skip_ro_mounting) = @_;
	return '' if(&error_if_mounted());
	my $squashfile = &get_abspath('FILE', 1);
	if(-f $squashfile) {
		$first_create = ''
	} elsif(!$first_create) {
		&error("squashfile $squashfile not found");
		return ''
	}
	return '' unless(&create_dir('DIR', 1));
	my $dir = $current->{'DIR'};
	if($first_create) {
		return '' unless(&first_create($squashfile, $dir))
	}
	my $ro_stat = &create_dir('READONLY', '');
	return '' unless($ro_stat);
	&info('mounting...') unless($quiet);
	if($ro_stat < 0) {
		return '' unless(&mount_squash($squashfile, $dir));
		$current->{'TYPE'} = 'readonly';
		delete($current->{'CHANGES'});
		return 1
	}
	my $dir_ro = $current->{'READONLY'};
	my $ret = 1;
	unless(defined($skip_ro_mounting) && $skip_ro_mounting) {
		my $mount_ro = 1;
		if(&is_nonempty($current->{'MOUNT_RO'})) {
			&warning("have mounted READONLY $dir_ro")
				unless($quiet > 1);
			$mount_ro = '' unless($ignore_state)
		}
		if($mount_ro) {
			unless(&mount_squash($squashfile, $dir_ro)) {
				return '' unless($ignore_state && $force);
				&warning('presuming mount was succesful due to -fI') unless($quiet > 1);
				$ret = ''
			}
			$current->{'MOUNT_RO'} = 1
		}
	}
	return '' unless(&create_dir('CHANGES', 1));
	my $type = &mount_rw($dir_ro, $dir, $current->{'CHANGES'});
	return '' unless(defined($type));
	$current->{'TYPE'} = $type;
	return $ret
}

# The main umount function.
# $will_squash and $will_remove will be calculated if they are not passed

sub umount_main {
	return &umount_readonly($quiet ? '' : 'umounting READONLY')
		unless($ignore_state || &is_nonempty($current->{'TYPE'}));
	my ($will_squash, $will_remove) = @_;
	($will_squash, $will_remove) = &check_squash($threshold, $kill)
		unless(defined($will_squash) && defined($will_remove));
	my $created = '';
	my $tempfile;
	my $dir = &get_abspath('DIR');
	$dir = undef unless(&is_abspath($dir));
	if($will_squash && defined($dir)) {
		&info('squashing (this may take a while)') unless($quiet);
		if(&is_abspath($tempdir)) {
			$tempfile = File::Temp->new(DIR => $tempdir)
		} else {
			$tempfile = File::Temp->new();
		}
		return '' unless(&mksquashfs($tempfile->filename, $dir, $squash_verbose));
		$created = 1
	}
	&info('umounting...') unless($quiet);
	my $ret = 1;
	my $message = '';
	unless(defined($dir) && &umount_dir($dir)) {
		&error('cannot determine DIR') unless(defined($dir));
		return '' unless($ignore_state && $force);
		&warning('presuming umount was succesful due to -fI') unless($quiet > 1);
		$ret = '';
		$message = 'umounting READONLY' unless($quiet)
	}
	delete($current->{'TYPE'});
	&reset_main(!$quiet) if($reset);
	$ret = '' unless(&umount_readonly($message));
	if($created) {
		my $squashfile = &get_abspath('FILE', 1);
		if(&is_nonempty($backup)) {
			my $file = (&is_abspath($backup) ? $backup :
				$squashfile . $backup);
			&info("$squashfile -> $file") unless($quiet);
			unlink($file);
			unless(move($squashfile, $file)) {
				&error("failed moving $squashfile to $file");
				return ''
			}
		}
		&info('tempfile' . ($verbose ?
			" \($tempfile\)" : '') . " \-\> $squashfile")
			unless($quiet);
		unlink($squashfile);
		$tempfile->unlink_on_destroy('');
		unless(move($tempfile->filename, $squashfile)) {
			&error("failed moving tempfile to $squashfile");
			return ''
		}
		&set_permissions($squashfile)
	}
	return 1 unless($will_remove);
	my $changes = &get_abspath('CHANGES');
	&title("$tag cleaning");
	&info('cleaning changes...') unless($quiet);
	return &clean_directory($changes)
}

# Umount readonly directory if mounted. Print argument if umounting

sub umount_readonly {
	return 1 unless($ignore_state || &is_nonempty($current->{'MOUNT_RO'}));
	my ($message) = @_;
	&info($message) if(defined($message) && ($message ne ''));
	my $dir_ro = &get_abspath('READONLY');
	return '' unless(&is_abspath($dir_ro) && &umount_dir($dir_ro));
	delete($current->{'MOUNT_RO'});
	return 1
}

# Return type in a human-readable form

sub human_type {
	my $type = $current->{'TYPE'};
	return $type if(&is_nonempty($type));
	return 'incompletely mounted' if(&is_nonempty($current->{'MOUNT_RO'}));
	return 'not mounted'
}

# The main reset function.

sub reset_main {
	my ($message) = @_;
	&info('resetting configuration') if($message);
	return &fill_current(1)
}

# print an error and return 1 if not at least halfmounted and not -I

sub error_unless_mounted {
	unless(&is_nonempty($current->{'TYPE'})
		|| &is_nonempty($current->{'MOUNT_RO'})) {
		unless($ignore_state) {
			&error('not mounted');
			return 1
		}
		&warning('apparently not mounted; ignoring due to -I')
	}
	return ''
}

# print an error and return 1 if mounted and not -I

sub error_if_mounted {
	if(&is_nonempty($current->{'TYPE'})) {
		unless($ignore_state) {
			&error('already mounted');
			return 1
		}
		&warning('apparently mounted; ignoring due to -I')
	}
	return ''
}

# This function is called for the first creation of the squash-file

sub first_create {
	my ($squashfile, $dir) = @_;
	&info('It seems this is mounted for the first time:',
		"The squashed file $squashfile does not exist yet;",
		"it will be initialized now from $dir") unless($quiet);
	return '' unless(&mksquashfs($squashfile, $dir, 2));
	&set_permissions($squashfile);
	# Sanity check: do not wipe if e.g. kernel has no squashfs support
	my $success = 1; {
		my $tmp = File::Temp::newdir();
		$success = '' unless(&mount_squash($squashfile, $tmp->dirname));
		$success = '' unless(&umount_dir($tmp->dirname))
	}
	unless($success) {
		&error('failed to mount generated squashfile ' . $squashfile,
			'skipping deletion of original DIR ' . $dir);
		return ''
	}
	&info('cleaning original DIR') unless($quiet);
	return &clean_directory($dir)
}

# Chmod and chown according to mountpoint defaults

sub set_permissions {
	my ($squashfile) = @_;
	my $ret = 1;
	my $chmod = &get_chmod();
	unless($chmod eq '') {
		unless(chmod($chmod, $squashfile)) {
			my $octal = sprintf('%#o', $chmod);
			&warning("chmod $octal $squashfile failed");
			$ret = ''
		}
	}
	my ($uid, $gid) = &get_chown();
	return $ret unless(defined($uid));
	unless(chown($uid, $gid, $squashfile)) {
		&warning("chown $uid:$gid $squashfile failed");
		$ret = ''
	}
	return $ret
}

# Return sanitized CHMOD value or empty

sub get_chmod {
	my $chmod = $user_config->{'CHMOD'};
	return 0644 unless(defined($chmod));
	return $chmod
}

# Return CHOWN values as array.

sub get_chown {
	my $chown = $user_config->{'CHOWN'};
	my ($uid, $gid) = (undef, undef);
	return (undef, undef) unless(defined($chown));
	if(ref($chown) eq 'ARRAY') {
		return (undef, undef) unless(@$chown);
		($uid, $gid) = @$chown
	} else {
		return (undef, undef) if($chown eq '');
		($uid, $gid) = split(/\D/, $chown)
	}
	$uid = -1 unless(defined($uid) && ($uid =~ /^\d+$/));
	$gid = -1 unless(defined($gid) && ($gid =~ /^\d+$/));
	return (undef, undef) if(($uid == -1) && ($gid == -1));
	return ($uid, $gid)
}

# The main function to mount read-writable. Returns type or undef

sub mount_rw {
	my ($ro, $rw, $changes) = @_;
	for my $i ($ro, $rw, $changes) {
		unless(-d $i) {
			&error("no directory $i");
			return ''
		}
	}
	for my $i (@CFG::order) {
		my $probemod = (($i =~ qr/\!/) ? (($i =~ qr/\!\!/) ? '' : -1) : 1);
		my $check_bin = ($i =~ qr/\#/);
		my $check_gz = (($i =~ qr/\?/) ? (($i =~ qr/\?\?/) ? -1 : 1) : '');
		if($i =~ qr/overlay/i) {
			return 'overlayfs' if(&mount_overlayfs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif($i =~ qr/aufs/i) {
			return 'aufs' if(&mount_aufs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif($i =~ qr/fuse/i) {
			return 'unionfs-fuse' if(&mount_unionfs_fuse($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} elsif($i =~ qr/funion/i) {
			return 'funionfs' if(&mount_funionfs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		} else { # ($i =~ qr/union/i)
			return 'unionfs' if(&mount_unionfs($probemod, $check_gz, $check_bin, $ro, $rw, $changes))
		}
	}
	&error('fallback to mount --bind');
	return (&mount_bind($ro, $rw) ? 'bind' : undef)
}

# Mount with overlayfs:

sub mount_overlayfs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' unless(&kernelprobe($probemod, $check_gz, 'overlayfs'));
	return '' if($check_bin && !&which_store(\$mount, 'mount'));
	&push_ref(\my @options, $user_config->{'MOUNT_OVERLAYFS'},
		['-o', 'noatime']);
	return 1 if(&my_system('', \$mount, 'mount', '-t', 'overlayfs', @options,
		'-o', "upperdir\=${changes}", '-o', "lowerdir\=${ro}",
		'--', 'overlayfs', $rw) == 0);
	&warning('overlayfs failed') unless($quiet > 1);
	return ''
}

# Mount with aufs:

sub mount_aufs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' unless(&kernelprobe($probemod, $check_gz, 'aufs'));
	return '' if($check_bin && !&which_store(\$mount, 'mount'));
	&push_ref(\my @options, $user_config->{'MOUNT_AUFS'},
		['-o', 'noatime']);
	$ro =~ s/([=:])/\\$1/g;
	$changes =~ s/([=:])/\\$1/g;
	return 1 if(&my_system('', \$mount, 'mount', '-t', 'aufs', @options,
		'-o', "br\:${changes}\=rw\:${ro}\=rr", '--', 'aufs', $rw) == 0);
	&warning('aufs failed') unless($quiet > 1);
	return ''
}

# Mount with unionfs-fuse

sub mount_unionfs_fuse {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_UNIONFS_FUSE'},
		['-o', 'cow', '-o', 'allow_other', '-o', 'use_ino',
		'-o', 'nonempty', '-o', 'noatime', '-o', 'hide_meta_files']);
	$ro =~ s/([=:])/\\$1/g;
	$changes =~ s/([=:])/\\$1/g;
	unless(&which_store(\$unionfs_fuse, 'unionfs', 'unionfs-fuse')) {
		return '' if($check_bin)
	}
	return '' unless(&kernelprobe($probemod, $check_gz, 'fuse'));
	push(@options, "${changes}\=RW\:${ro}\=RO", $rw);
	return 1 if(&my_system('', \$unionfs_fuse, 'unionfs', @options) == 0);
	if(&which_which() eq '') { # We have no which
		my $fuse = 'unionfs-fuse ';  # perhaps this will work
		if($unionfs_fuse ne $fuse) { # unless we already tried
			if(&my_system('', \$fuse, $fuse, @options) == 0) {
				$unionfs_fuse = $fuse; # remember: this is ok
				return 1
			}
		}
	}
	&warning('unionfs-fuse failed') unless($quiet > 1);
	return ''
}

# Mount with unionfs

sub mount_unionfs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' unless(&kernelprobe($probemod, $check_gz, 'unionfs'));
	return '' if($check_bin && !&which_store(\$mount, 'mount'));
	&push_ref(\my @options, $user_config->{'MOUNT_UNIONFS'},
		['-o', 'noatime']);
	$ro =~ s/([=:])/\\$1/g;
	$changes =~ s/([=:])/\\$1/g;
	return 1 if(&my_system('', \$mount, 'mount', '-t', 'unionfs', @options,
		'-o', "dirs\=${changes}\=rw\:${ro}\=ro", '--', 'unionfs', $rw) == 0);
	&warning('unionfs failed') unless($quiet > 1);
	return ''
}

# Mount with funionfs

sub mount_funionfs {
	my ($probemod, $check_gz, $check_bin, $ro, $rw, $changes) = @_;
	return '' if($check_bin && !&which_store(\$mount, 'mount'));
	return '' unless(&kernelprobe($probemod, $check_gz, 'fuse'));
	&push_ref(\my @options, $user_config->{'MOUNT_FUNIONFS'},
		['-o', 'allow_other', '-o', 'nonempty']);
	$ro =~ s/\=/\\\=/g;
	return 1 if(&my_system('', \$funionfs, 'funionfs', $changes, $rw, @options,
		'-o', "dirs\=${ro}\=ro") == 0);
	&warning('funionfs failed') unless($quiet > 1);
	return ''
}

# Mount with bind:

sub mount_bind {
	my ($from, $to) = @_;
	return 1 if(&my_system('', \$mount, 'mount', '--bind', '--', $from, $to) == 0);
	&error('mount --bind failed');
	return ''
}

# Mount the squash-file readonly:

sub mount_squash {
	my ($squashfile, $dir) = @_;
	unless(-d $dir) {
		&error("no directory $dir");
		return ''
	}
	if($modprobe_squash) {
		$modprobe_squash = '';
		&my_modprobe('squashfs')
	}
	return 1 if(&my_system('', \$mount, 'mount','-t', 'squashfs',
		'-o', 'loop,ro,noatime', '--', $squashfile, $dir) == 0);
	&error('failed to mount squashfile');
	return ''
}

# Create the squash file:

sub mksquashfs {
	my ($squashfile, $dir, $squash_verbose) = @_;
	unless(-d $dir) {
		&error("no directory $dir");
		return ''
	}
	&mksquashfs_options(\my @options);
	&title("$tag squashing");
	my $oldout = undef;
	my $ret = (&my_system(($squash_verbose != 2), \$mksquashfs, 'mksquashfs', $dir, $squashfile, @options) == 0);
	&error($verbose ? 'failed: ' . &join_quoted($mksquashfs, $dir, $squashfile, @options)
		: 'mksquashfs failed') unless($ret);
	return $ret
}

# Set array of options for mksquashfs:

sub mksquashfs_options {
	my ($options) = @_;
	@$options = ('-noappend');
	push(@$options, '-no-progress') if($squash_verbose == 0);
	push(@$options, '-always-use-fragments') if(&is_nonempty($user_config->{'DEFAULT_FRAGMENTS'}));
	my $comp = (defined($compression) ? lc($compression) : 'lz4');
	my $compopt = $user_config->{'COMPOPT_' . uc($comp)};
	unless(defined($compopt)) {
		$compopt = '-Xhc' if($comp eq 'lz4')
	}
	push(@$options, '-comp', $comp) if($comp ne '');
	&push_ref($options, $compopt, undef);
	&push_ref($options, $user_config->{'MKSQUASHFS'}, undef)
}

# Umount the directoy, possibly lazily:

sub umount_dir {
	my ($dir) = @_;
	my $ret = (&my_system(1, \$umount, 'umount', '--', $dir) == 0);
	unless($ret) {
		if($lazy) {
			&error('non-lazy umount failed,',
				"using lazy umount of $dir") unless($quiet > 1);
			$ret = (&my_system(1, \$umount, 'umount', '-l', '--', $dir) == 0);
			&error("lazy umount failed: $dir") unless($ret)
		} else {
			&error('non-lazy umount failed')
		}
	}
	return $ret
}

# Check whether squashing is necessary, taking $current and options into account
# Returns ($will_squash, $will_remove).
# $will_remove = -1 denotes cleaning a presumably empty directory.

sub check_squash {
	my ($threshold, $kill) = @_;
	return ('', 0) if(($threshold < 0) || !&is_resquash_type());
	return ('', 1) if($kill);
	my $thr = &threshold_dir($threshold);
	return ('', -1) if($thr == 0); # clean "empty" directory
	return (1, 1) if($thr > 0);
	return ('', 0)
}

# Execute modprobe for the argument

{ my %probed = (); # A closure static variable
sub my_modprobe {
	my ($module) = @_;
	my $probed = $probed{$module};
	return $probed if(defined($probed));
	$probed = $probed{$module} =
		(&my_system(2, \$modprobe, 'modprobe', $module) == 0);
	return $probed
}}

# use IO::Uncompress::Gunzip qw(gunzip) and return whether successful

{ my $gunzip = undef; # A closure static variable
sub use_gunzip {
	return $gunzip if(defined($gunzip));
	eval {
		require IO::Uncompress::Gunzip;
		IO::Uncompress::Gunzip->import(qw(gunzip))
	};
	return ($gunzip = 1) unless($@);
	return ($gunzip = '')
}}

# Assuming that use_gunzip() has previously been called with success,
# read the kernel configuration. Return 1 on success.

sub read_kernel_config {
	my ($gz) = @_;
	my $buffer;
	return '' unless(gunzip('/proc/config.gz' => \$buffer));
	$gz->{'overlayfs'} = 1 if($buffer =~ qr/^CONFIG_OVERLAYFS_FS/m);
	$gz->{'aufs'} = 1 if($buffer =~ qr/^CONFIG_AUFS_FS/m);
	$gz->{'unionfs'} = 1 if($buffer =~ qr/^CONFIG_UNION_?FS/m);
	$gz->{'fuse'} = 1 if($buffer =~ qr/^CONFIG_FUSE_FS/m);
	return 1
}

# Probe module and/or check the kernel configuration. Return 1 on success

{ my $gz = undef; # A closure static variable
sub kernelprobe {
	my ($probemod, $check_gz, $module) = @_;
	return 1 if($probemod && &my_modprobe($module) && ($probemod > 0));
	return 1 unless($check_gz);
	unless(defined($gz)) {
		if(&use_gunzip()) {
			$gz = {};
			$gz = 1 unless(&read_kernel_config($gz))
		} else {
			$gz = ''
		}
	}
	if(ref($gz) eq '') {
		return 1 unless($gz);
		return ($check_gz > 0)
	}
	my $ret = $gz->{$module};
	return '' unless(defined($ret));
	return $ret
}}

# The main function to read a configuration file:

# The default config must be parsed before the function
{
	package CFG;
	our $lazy = 1;
	our $killpower = [ '/etc/killpower', '/etc/nosquash' ];
	our $squash_verbose = 1;
	our $modprobe_squash = 1;
	our $locking;
	our @order = ();
	our @mounts = ();
}

sub read_config_file {
	my ($file) = @_;
	$file = abs_path($file);
	unless(-f $file) {
		&warning("skipping config file $file (not a file)") unless($quiet);
		return
	}
	&info("reading config file $file") if($verbose > 2);
	package CFG;
	our $lazy;
	our $killpower;
	our $squash_verbose;
	our $locking;
	our @order;
	our @mounts;
	sub standard_mount($$@) {
		my ($tag, $dir, @rest) = @_;
		return &added_hash({
			TAG => $tag,
			DIR => $dir,
			CHANGES => $dir . '.changes',
			READONLY => $dir . '.readonly',
			FILE => $dir . '.sqfs',
		}, @rest)
	}
	sub added_hash(@) {
		my $a = {};
		for my $i (@_) {
			for my $j (keys(%$i)) {
				$a->{$j} = $i->{$j}
			}
		}
		return $a
	}
	unless(my $ret = do($file)) {
		die "error parsing $file: $@\nstopped" if($@);
		die "error running $file\nstopped" if(defined($ret) && !$ret)
	}
}

# Read settings from /run/squashmount:

sub read_settings {
	my $file = &settings_file();
	if(open(my $fh, '<', $file)) {
		if($locking) {
			$lockfh = $fh; # unlock even if we die
			flock($lockfh, LOCK_SH)
		}
		{
			package RUNCFG;
			our %data = ();
			do($file);
		}
		close($fh) unless(&end_locking());
		%$current = %RUNCFG::data
	} else {
		%$current = ()
	}
}

# Write settings to /run/squashmount and unlock:

sub write_settings {
	my $file = &settings_file();
	my $fh;
	if(defined($lockfh)) {
		$fh = $lockfh;
		unless(seek($fh, 0, SEEK_SET)) {
			&error("cannot seek $file");
			return ''
		}
		unless(truncate($fh, 0)) {
			&error("cannot truncate $file");
			return ''
		}
	} else {
		unless(open($fh, '>', $file)) {
			&error("cannot open $file for writing");
			return ''
		}
		if($locking) {
			$lockfh = $fh; # unlock even if we die
			flock($lockfh, LOCK_EX)
		}
	}
	my $ret = 1;
	for my $i (keys(%$current)) {
		my $value = $current->{$i};
		next unless(defined($value));
		my $write = "\$data\{\'$i\'\} = ";
		if($i eq 'THRESHOLD') {
			$write = "\{\n\tuse bigint\;\n\t$write$value\n\}\n"
		} elsif($value eq '') {
			$write .= "'';\n"
		} elsif($value =~ qr/^\-?\d*$/) {
			$write .= "$value\;\n"
		} else {
			$write .= '"' . quotemeta($value) . "\"\;\n"
		}
		unless(print($fh $write)) {
			&error("cannot write to $file") unless($ret);
			$ret = ''
		}
	}
	close($fh) unless(&end_locking());
	return $ret
}

# forget settings in /run/squashmount if $current_empty suggests to.

sub remove_settings {
	return '' unless(defined($current_empty));
	return '' unless(&hash_equal($current_empty, $current));
	my $file = &settings_file();
	return 1 unless(-f $file);
	return unlink($file)
}

# Start locking in /run/squashmount unless $run_ro

sub start_locking {
	return unless($locking && !$run_ro);
	my $file = &settings_file();
	unless(open($lockfh, '>>', $file)) {
		$lockfh = undef;
		return
	}
	flock($lockfh, LOCK_EX);
}

# End locking in /run/squashmount. Return 1 if we had a lock

sub end_locking {
	return '' unless(defined($lockfh));
	flock($lockfh, LOCK_UN);
	close($lockfh);
	$lockfh = undef;
	return 1
}

# Forget settings from $current and remember new state in $current_empty

sub forget_settings {
	&info('forgetting settings') unless($quiet);
	$current = {};
	&fill_current();
	&set_globals();
	$current_empty = {};
	%$current_empty = %$current
}

# Return the filename in /run/squashmount for the current tag

sub settings_file {
	return File::Spec->catfile($rundir, $tag)
}

# Fill "global" variables according to options and $current state

sub set_globals {
	$backup = (defined($opt_backup) ? $opt_backup :
		$current->{'BACKUP'});
	$tempdir = (defined($opt_tempdir) ? $opt_tempdir :
		$current->{'TEMPDIR'});
	$compression = (defined($opt_compression) ? $opt_compression :
		$current->{'COMPRESSION'});
	$threshold = (($opt_threshold ne '') ?
		&parse_threshold($opt_threshold) : $current->{'THRESHOLD'});
	if($threshold < 0) {
		$kill = ''
	} else {
		$kill = (defined($opt_kill) ? $opt_kill : $current->{'KILL'})
	}
}

# Fill $current state with defaults from $user_config.

sub fill_current {
	my ($force) = @_;
	$force = '' unless(defined($force));
	if($force || !exists($current->{'BACKUP'})) {
		$current->{'BACKUP'} = $user_config->{'BACKUP'}
	}
	if($force || !exists($current->{'TEMPDIR'})) {
		$current->{'TEMPDIR'} = $user_config->{'TEMPDIR'}
	}
	if($force || !exists($current->{'COMPRESSION'})) {
		$current->{'COMPRESSION'} = $user_config->{'COMPRESSION'}
	}
	if($force || !exists($current->{'THRESHOLD'})) {
		$current->{'THRESHOLD'} = &parse_threshold($user_config->{'THRESHOLD'})
	}
	if($force || !exists($current->{'KILL'})) {
		$current->{'KILL'} = $user_config->{'KILL'}
	}
	return 1
}

# Turn argument into a number.

sub parse_threshold {
	my ($threshold) = @_;
	return 0 unless(defined($threshold));
	$threshold =~ s/[[:space:]]//g;
	$threshold =~ s/^\+//;
	return 0 unless($threshold =~ qr/^(\-?\d+)([kKmMgGtT])?$/);
	use bigint;
	my ($num, $ext) = ($1, $2);
	return (-1) if($num < 0);
	return $num unless(defined($ext) && ($ext ne ''));
	for my $i (qr/[kK]/, qr/[mM]/, qr/[gG]/) {
		$num *= 1024;
		return $num if($ext =~ $i)
	}
	return ($num * 1024) # if($ext =~ qr/[tT]/)
}

# Turn argument into a human-readable string

sub human_threshold {
	use bigint;
	my ($threshold) = @_;
	my $append = '';
	for my $i ('k', 'm', 'g', 't') {
		return "$threshold$append" if($threshold < 512);
		$threshold = &roundup($threshold, 1024);
		$append = $i
	}
	return "$threshold$append"
}

# Return $a / $b rounded up

sub roundup {
	use bigint;
	my ($a, $b) = @_;
	return (($a + $b - 1) / $b)
}

# Check whether passed configuration has a directory from $pass_dir

sub find_pass_dir {
	my ($hash, $pass_dir) = @_;
	for my $i (
		$hash->{'DIR'},
		$hash->{'CHANGES'},
		$hash->{'READONLY'}) {
		return 1 if(exists($pass_dir->{$i}))
	}
	return ''
}

# Initialize and create $current->{$i} from $user_config->{$i} if necessary
# Returns 1 on success -1 if directory is a nonempty non-path, '' otherwise

sub create_dir {
	my ($i, $require_dir) = @_;
	if(exists($current->{$i})) {
		return (&is_abspath($current->{$i}) ? 1 : -1)
	}
	my $dir = &create_dirname($user_config->{$i});
	unless(is_nonempty($dir)) {
		&error("failed to create $i");
		return ''
	}
	if(&is_abspath($dir)) {
		$current->{$i} = $dir;
		return 1
	}
	if($require_dir) {
		&error("no absolute directory $i");
		return ''
	}
	$current->{$i} = 1;
	return -1
}

# Fetch a filename from @CFG::mounts, creating the directory if necessary

sub create_dirname {
	my ($temp) = @_;
	$temp = '' unless(defined($temp));
	if(ref($temp) eq 'CODE') {
		$temp = &{$temp}($tag)
	}
	if(ref($temp) eq 'File::Temp::Dir') {
		$temp->unlink_on_destroy('');
		$temp = $temp->dirname;
	} elsif($temp eq '') {
		$temp = File::Temp::newdir(undef, CLEANUP => '');
		$temp = $temp->dirname;
	}
	return $temp unless(&is_abspath($temp));
	unless(-d $temp) {
		return undef unless &make_directory($temp);
	}
	return abs_path($temp)
}

# Return whether CHANGES makes sense and is a directory.
# With $create_dir, create it if necessary.

sub is_valid_changes {
	my ($create_dir) = @_;
	my $result = &is_resquash_type();
	return 1 if($result);
	return '' if($result ne '');
	return '' unless(&is_abspath(&get_abspath('READONLY', $create_dir, '')));
	return &is_abspath(&get_abspath('CHANGES', $create_dir, 1));
}

# Return absolute path from $current or $user_config.
# With $create_dir and $required_dir call &create_dir(..., $required_dir).
# With $create_dir only take resolved path to $user_config if possible.

sub get_abspath {
	my ($i, $create_dir, $required_dir) = @_;
	$create_dir = '' unless(defined($create_dir));
	&create_dir($i, $required_dir) if($create_dir && defined($required_dir));
	my $ret = $current->{$i};
	return $ret if(defined($ret));
	$ret = $user_config->{$i};
	return '' unless(defined($ret) || (ref($ret) ne ''));
	$ret = abs_path($ret) if(&is_abspath($ret));
	$current->{$i} = $ret if($create_dir);
	return $ret
}

# Test if type is valid type for resquashing.
# Result is 1 (yes) or 0 (no) or the empty string if type is not known

sub is_resquash_type {
	my $type  = $current->{'TYPE'};
	return '' unless(defined($type) && ($type ne ''));
	return 0 if(($type eq 'readonly') || ($type =~ qr/bind/));
	return 1
}

# Check whether dir is empty. Returns 1 or '', or 0 in case of error

sub dir_is_empty {
	my ($dir) = @_;
	my $dh = undef;
	return 0 unless(opendir($dh, $dir));
	for(;;) {
		my $curr = readdir($dh);
		unless(defined($curr)) {
			closedir($dh);
			return 1
		}
		if(scalar(File::Spec->no_upwards(($curr)))) {
			closedir($dh);
			return ''
		}
	}
}

# Check whether CHANGES tree is empty or is more than $to_find long.
# Return value 1 means $to_find is reached, -1 means nonempty but not reached.

sub threshold_dir {
	my ($to_find) = @_;
	my $dir = &get_abspath('CHANGES');
	my $readonly = &get_abspath('READONLY');
	my $found = ''; # Flag whether there is at least some data
	my $blocksize;
	{
		use bigint;
		my $bs = $user_config->{'BLOCKSIZE'};
		$blocksize = ((defined($bs) && ($bs > 0)) ? $bs : 4096 );
	}
	my $skipfunc = $user_config->{'SKIPFUNC'};
	my $skip = $user_config->{'SKIP'};
	my $skipdir = $user_config->{'SKIPDIR'};
	my $check = $user_config->{'DIFF'};
	my $fill = $user_config->{'FILL'};
	my $fillfunc = $user_config->{'FILLFUNC'};

	# Now some hidden files/directories for special filesystems:
	# We skip these files also if the $type does not match;
	# otherwise there would be confusion if e.g. changing from
	# aufs to overlayfs and thus suddenly aufs-hidden files are visible.
	# However, more exact would be to use the if-clauses of the comments:
	# my $type = $current->{'TYPE'};
	push(@$skip, qr/^\._funionfs/); # if($type eq 'funionfs')
	push(@$skipdir, qr/^\.unionfs/);# if($type =~ qr/^unionfs/)
	push(@$skip, qr/^\.wh\.\.wh\.aufs$/) &&
	push(@$skipdir, qr/^\.wh\.\.wh\.((pli?nk)|(\.tmp)|orph)/);# if($type eq 'aufs')

	my @compare = (); # postponed file content comparison...
	find({
		no_chdir => 1,
		follow => '',
		follow_fast => 1,
		follow_skip => 2,
		dangling_symlinks => '',
		wanted => sub {
		if($to_find < 0) {
			# Shortcut possible
			$File::Find::prune = 1;
			return
		}
		my $path = (substr($_, 0, length($dir)) ne $dir) ?
			$_ : substr($_, length($dir));
		$path =~ s{^/}{};
		return if(($path eq '') || &is_match($path, $skip));
		if(&is_match($path, $skipdir) && (-d $_) && !(-l $_)) {
			$File::Find::prune = 1;
			return
		}
		if(&is_match($path, $check)) {
			return if &file_is_equal($_, $readonly . "/$path", \@compare)
		}
		if(defined($skipfunc) && (ref($skipfunc) eq 'CODE')) {
			local($_);
			return unless(&{$skipfunc}($path, $_, $readonly . "/$path"))
		}
		my $currfill = &is_match($path, $fill);
		if((!$currfill) && defined($fillfunc) && (ref($fillfunc) eq 'CODE')) {
			local($_);
			$currfill = &{$fillfunc}($path, $_, $readonly . "/$path")
		}
		$found = 1;
		if($currfill) {
			use bigint;
			$to_find = -1
		} else {
			use bigint;
			my $size = (((-l $_) || !(-f $_)) ? 1 : (-s $_));
			$size = 1 if($size == 0);
			my $modulo = ($size % $blocksize);
			$size += ($blocksize - $modulo) if($modulo != 0);
			$to_find -= $size
		}
		$File::Find::prune = 1 if($to_find < 0)
	}}, $dir);
	return 1 if($to_find < 0);
	# Only if $to_find is not reached we now do have to compare
	# also the content of files:
	# If the files differ, they add to $to_find...
	for my $i (@compare) {
		next if(compare($i->[0], $i->[1]) == 0);
		$to_find -= $i->[2];
		return 1 if($to_find < 0);
		$found = 1
	}
	return ($found ? -1 : 0)
}

# subfunction of threshold_dir: Check whether filetypes are equal.
# For files, postpone content comparison by pushing [ $a, $b, $filesize]
# to @$compare.

sub file_is_equal {
	my ($a, $b, $compare) = @_;
	if(-l $a) {
		return (-l $b);
	}
	return '' if(-l $b);
	if(-d $a) {
		return (-d $b)
	}
	if(-f $a) {
		if(-f $b) {
			{
				use bigint;
				my $size = (-s $a);
				return '' if($size ne (-s $b));
				push(@$compare, [ $a, $b, $size ])
			}
			return 1
		}
		return ''
	}
	return !(-f $b)
}

# Compare against an array of regular expressions

sub is_match {
	my($a, $reg) = @_;
	for my $r (@$reg) {
		return 1 if($a =~ $r)
	}
	return ''
}

# Make a directory with parents

sub make_directory {
	my ($dir) = @_;
	make_path($dir, { error => \my $err });
	return undef unless(&filepath_ok($err, 1))
}

# Clean all files from a directory

sub clean_directory {
	my ($dir) = @_;
	if($interactive) {
		print("Clean $dir? ");
		unless(<STDIN> =~ qr/^y/i) {
			&info("keeping $dir") if($verbose);
			return 1
		}
	}
	&info("cleaning $dir") if($verbose);
	remove_tree($dir, {
		keep_root => 1,
		error => \my $err
	});
	return &filepath_ok($err, '')
}

# Handle the error of make_path or remove_tree. Return true if no error

sub filepath_ok {
	my ($err, $make_path) = @_;
	return 1 unless(@$err);
	my $text = $make_path ? 'creating' : 'removing';
	for my $diag (@$err) {
		my ($file, $message) = %$diag;
		if($file eq '') {
			&error("(while $text): $message")
		} else {
			&error("(while $text $file): $message")
		}
	}
	return ''
}

# Output fatal error and die:

sub fatal {
	&output(\@_, 1, 'red', 'fatal: ', 1);
	exit(1)
}

# Output errors:

sub error {
	return &output(\@_, 1, 'red', 'error:   ')
}

# Output errors without specifying "error"

sub errorinfo {
	return &output(\@_, 1, 'red')
}

# Output warnings:

sub warning {
	return &output(\@_, 1, 'yellow', 'warning: ')
}

# Output informal messages:

sub info {
	return &output(\@_, 1, 'green')
}

# Main action of fatal, error, warning, info:

sub output {
	my ($array, $to_stderr, $colorname, $label, $notag) = @_;
	$label = '' unless(defined($label));
	my $col = '';
	my $reset = '';
	if((!defined($opt_color)) || $opt_color) {
		my $use_color = $opt_color;
		unless(defined($use_color)) {
			$use_color = $stdoutterm;
			if($to_stderr) {
				$stderrterm = (-t STDOUT) unless(defined($stderrterm));
				$use_color = $stderrterm
			}
		}
		if($use_color && &use_ansicolor()) {
			$col = color($colorname);
			$reset = color('reset')
		}
	}
	my $first = '';
	my $len = length($label);
	if($star) {
		$len += 3;
		$first = ' ' . $col . '*' . $reset . ' '
	}
	if((defined($notag) && ($notag ne '')) || ($tag eq '')) {
		$len += length($name) + 2;
		$first .= $col . $name . $reset . ': '
	} else {
		$len += $taglen + 4;
		$first .= '[' . $col . $tag . $reset . ']: '
			. (' ' x ($taglen - length($tag)))
	}
	$first .= $label . $array->[0] . "\n";
	my @copy = @$array;
	my $s = (' ' x $len);
	grep($_ = "$s$_\n", @copy);
	$copy[0] = $first;
	return print(STDERR @copy) if($to_stderr);
	return print(@copy)
}

# Set title:

sub title {
	return unless(defined($titleopt) && &which_store(\$title, 'title'));
	my ($a) = @_;
	my @opt = ();
	push(@opt, "\-$titleopt") if($titleopt ne '');
	if(system($title, @opt, '--', $a) == 0) {
		$printed_title = 1;
		return
	}
	# Apparently title is not available or does something else...
	$printed_title = '';
	$titleopt = undef
}

# If title was called once or we locked, we have to reset this on every exit:

END {
	&end_locking();
	&title(($? == 0) ? "$name finished" : "$name failed")
		if(defined($printed_title) && $printed_title)
}

# Output of print-..., returning '' if undefined

sub do_print {
	my ($a) = @_;
	my $ret = 1;
	unless(defined($a)) {
		$ret = $a = '';
		$a = '(undefined)' unless($quiet)
	}
	if($quiet) {
		print($a . $separator);
		return $ret
	}
	if($ret) {
		&info($a);
		return 1
	}
	&errorinfo($a);
	return $ret
}

# Output of status-array

sub print_status {
	my ($a) = @_;
	if($verbose) {
		&info(@$a)
	} else {
		&info(join(', ', @$a))
	}
}

# Call to which_store() followed by system(). Print error if tool not found.
# The first argument is special:
# '' or 0: Default mode
# 1: suppress stdout
# 2: suppress stdout and stderr

sub my_system {
	my $redirect = shift();
	my $a = shift();
	my $b = shift();
	unless(&which_store($a, $b)) {
		&error($b . ' not found in $PATH');
		return 127
	}
	print(&join_quoted($$a, @_), "\n") if($verbose > 2);
	my $oldout = undef;
	my $olderr = undef;
	if($redirect) {
		if($redirect > 1) {
			$olderr = undef unless(open($olderr, '>&', \*STDERR) && open(STDERR, '>', $devnull))
		}
		$oldout = undef unless(open($oldout, '>&', \*STDOUT) && open(STDOUT, '>', $devnull))
	}
	my $ret = system($$a, @_);
	open(STDERR, '>&', $olderr) if(defined($olderr));
	open(STDOUT, '>&', $oldout) if(defined($oldout));
	return $ret
}

# Store in the first argument the first successful "which" of the later.
# Return 1 if none found.

sub which_store {
	my $a = shift();
	return ($$a ne '') if(defined($$a));
	for my $i (@_) {
		$$a = &my_which($i);
		return ($$a ne '') if(defined($$a))
	}
	return ($$a = '')
}

# Act like which() with a fallback to `which ...`; if neither is available,
# returns the argument as "path". Must be used in scalar context.

sub my_which {
	my ($command) = @_;
	my $which = &which_which();
	return which($command) if($which eq ':');
	return $command if($which eq '');
	my $ret = `$which $command`;
	chomp($ret) if(defined($ret));
	return $ret
}

# use File::Which module and return ':'
# As a fallback a path to "which" or the empty string is returned

{ my $which = undef; # A closure static variable
sub which_which {
	return $which if(defined($which));
	eval {
		require File::Which;
		File::Which->import()
	};
	return ($which = ':') unless($@);
	my $olderr;
	$olderr = undef unless(open($olderr, '>&', \*STDERR) && open(STDERR, '>', $devnull));
	$which = `which which`;
	open(STDERR, '>&', $olderr) if(defined($olderr));
	return ($which = '') unless(defined($which));
	chomp($which);
	return $which
}}

# use Term::ANSIColor and return whether successful

{ my $ansicolor = undef; # A closure static variable
sub use_ansicolor {
	return $ansicolor if(defined($ansicolor));
	eval {
		require Term::ANSIColor;
		Term::ANSIColor->import()
	};
	return ($ansicolor = 1) unless($@);
	return ($ansicolor = '')
}}

# Is argument defined and nonempty?

sub is_nonempty {
	my ($arg) = @_;
	return (defined($arg) && ($arg ne ''))
}

# Is argument defined and an absolute path?

sub is_abspath {
	my ($arg) = @_;
	return (&is_nonempty($arg) && (File::Spec->file_name_is_absolute($arg)))
}

# compare two hashes

sub hash_equal {
	my ($a, $b) = @_;
	for my $i (keys(%$a)) {
		next unless(defined($a->{$i}));
		return '' unless(defined($b->{$i}));
		return '' unless($a->{$i} eq $b->{$i})
	}
	for my $i (keys(%$b)) {
		next unless(defined($b->{$i}));
		return '' unless(exists($a->{$i}))
	}
	return 1
}

# push string or reference to array of strings. If $s is undefined use $t

sub push_ref {
	my ($arr, $s, $t) = @_;
	$s = $t unless(defined($s));
	return unless(defined($s));
	if(ref($s) eq 'ARRAY') {
		push(@$arr, @$s);
		return
	}
	push(@$arr, $s) if($s ne '')
}

# like join(' ', @_), but shell-quote arguments

sub join_quoted {
	my @r;
	for my $i (@_) {
		my $a = $i;
		$a =~ s/\'/\'\\\'\'/go;
		$a = "'" . $a . "'";
		$a =~ s/(^|[^\\])\'([\da-zA-Z\_\-\,\.\:\/]*)\'/$1$2/g;
		push(@r, ($a ne '') ? $a : "''")
	}
	return join(' ', @r)
}

# set $had_error and $exitstatus according to $errorbreak and $fatalreturn

sub bad_status {
	$had_error = 1 if($errorbreak);
	$exitstatus = 1 unless($fatalreturn || ($exitstatus != 0))
}

# check whether argument is a nonempty string and the corresponding file exists

sub file_exists {
	my ($f) = @_;
	return(defined($f) && (ref(\$f) eq 'SCALAR') && ($f ne '') && (-e $f))
}

#
# Now the main program:
#

# Parse Options:

$Getopt::Long::bundling = 1;
GetOptions(
	'help|h', sub { pod2usage(1) },
	'man|?', sub { pod2usage(-verbose => 2) },
	'version|V', \&version,
	'config|c=s', \@configs,
	'rundir=s', \$rundir,
	'separator|S=s', \$separator,
	'interactice|i', \$interactive,
	'threshold|t=s', \$opt_threshold,
	'no-squash|nosquash|n', sub { $opt_threshold = '-1' },
	'squash|squash|s', sub { $opt_threshold = '0' },
	'kill|k', \$opt_kill,
	'no-kill|nokill|K', sub { $opt_kill = '' },
	'compression|comp|x=s', \$opt_compression,
	'tempdir|D=s', \$opt_tempdir,
	'backup|b=s', \$opt_backup,
	'no-backup|nobackup|B', sub { $opt_backup = '' },
	'squash-verbose=i', \$squash_verbose,
	'lazy!', \$lazy,
	'locking!', \$locking,
	'force|f', \$force,
	'ignore-state|I', \$ignore_state,
	'reset|r', \$reset,
	'pass-dir', \$pass_dir,
	'title|T=s', \@title,
	'color|F', \$opt_color,
	'no-color|nocolor|C', sub { $opt_color = '' },
	'star!', \$star,
	'fatal!', \$fatalreturn,
	'error|e', \$errorbreak,
	'no-error|noerror|E', sub { $errorbreak = '' },
	'first|1', \$firstmatch,
	'verbose|v+', \$verbose,
	'quiet|q+', \$quiet
) or pod2usage(2);

# Check options:

&fatal("$rundir is not an absolute path") unless(&is_abspath($rundir));
for my $i (@configs) {
	&fatal("config-file $i is not an absolute path")
		unless(&is_abspath($rundir))
}

# Postprocess options:

@configs = (File::Spec->catfile($root, 'etc', 'squashmount.pl'))
	unless(@configs);
if($quiet < $verbose) {
	$verbose -= $quiet; $quiet = 0
} else {
	$quiet -= $verbose; $verbose = 0
}
$titleopt = join('', @title);
undef(@title);
$titleopt = undef if(($titleopt =~ qr/-/) || !$stdoutterm);

# Determine $action, $fatalreturn, $run_ro, $star, $CFG::locking, @CFG::order

my $action = shift(@ARGV);
{
	$action = '' unless(defined($action));
	my $order_needed = '';
	$run_ro = '';
	if($action =~ /^p/i) {
		$run_ro = 1;
		if($action =~ /tag/i) {
			$action = \&cmd_print_tag
		} elsif($action =~ /dir/i) {
			$action = \&cmd_print_dir
		} elsif($action =~ /chan/i) {
			$action = \&cmd_print_changes
		} elsif($action =~ /read|ro/i) {
			$action = \&cmd_print_readonly
		} elsif($action =~ /fil/i) {
			$action = \&cmd_print_file
		} elsif($action =~ /typ/i) {
			$action = \&cmd_print_type
		} elsif($action =~ /new|mod/i) {
			$action = \&cmd_print_new
		} elsif($action =~ /will|sq|comp/i) {
			$action = \&cmd_print_will_squash
		} elsif($action =~ /thr/i) {
			$action = \&cmd_print_threshold
		} elsif($action =~ /kil/i) {
			$action = \&cmd_print_kill
		}
	} elsif($action =~ /^(stat|l)/i) {
		$run_ro = 1;
		$action = \&cmd_status
	} elsif($action =~ /^mo/i) {
		$order_needed = 1;
		$action = \&cmd_mount
	} elsif($action =~ /^star/i) {
		$order_needed = 1;
		$fatalreturn = 1 unless(defined($fatalreturn));
		$action = \&cmd_start
	} elsif($action =~ /^cr/i) {
		$action = \&cmd_create
	} elsif($action =~ /^ch/i) {
		$run_ro = 1;
		$lazy = '' unless(defined($lazy));
		$action = \&cmd_check
	} elsif($action =~ /set/i) {
		if($action =~ /[ur]/i) {
			$action = \&cmd_reset
		} else {
			$action = \&cmd_set
		}
	} elsif($action =~ /^u/i) {
		$action = \&cmd_umount
	} elsif($action =~ /^sto/i) {
		$fatalreturn = 1 unless(defined($fatalreturn));
		$action = \&cmd_stop
	} elsif($action =~ /^rem/i) {
		$order_needed = 1;
		$action = \&cmd_remount
	} elsif($action =~ /^rest/i) {
		$fatalreturn = 1 unless(defined($fatalreturn));
		$order_needed = 1;
		$action = \&cmd_restart
	} elsif($action =~ /^for/i) {
		$action = \&cmd_forget
	} elsif($action =~ /^m/i) {
		pod2usage(-verbose => 2)
	} elsif($action =~ /^h|\?/i) {
		pod2usage(0)
	}
	pod2usage(2) unless(ref($action) eq 'CODE');
	$fatalreturn = '' unless(defined($fatalreturn));
	$star = 1 # !$run_ro # Use this to make --no-star the default for infos
		unless(defined($star));
	$run_ro = '' if($force || $ignore_state);
	$CFG::locking = !$run_ro;
	@CFG::order = qw(overlayfs!? aufs! unionfs-fuse! unionfs! funionfs!)
		if($order_needed)
}

# Read config files:

for my $file (@configs) {
	&read_config_file($file)
}

# Modify options according to config:

$squash_verbose = $CFG::squash_verbose unless(defined($squash_verbose));
$lazy = $CFG::lazy unless(defined($lazy));
$locking = $CFG::locking unless(defined($locking));
$modprobe_squash = $CFG::modprobe_squash;
if(defined($CFG::killpower)) {
	if(ref($CFG::killpower) eq 'ARRAY') {
		for my $i (@$CFG::killpower) {
			if(&file_exists($i)) {
				$opt_threshold = '-1';
				last
			}
		}
	} elsif(&file_exists($CFG::killpower)) {
		$opt_threshold = '-1'
	}
}

# Fill the %tags array in the appropriate order.
# As a side result calculate $taglen.

my %tags = ();
$taglen = 0;
for(my $i = 0; $i < @CFG::mounts; ++$i) {
	my $mountpoint = $CFG::mounts[$i];
	&fatal('config error: element ' . ($i + 1) . ' of @mounts is not a hash reference')
		unless(ref($mountpoint) eq 'HASH');
	my $tag = $mountpoint->{'TAG'};
	&fatal('config error: mount-point ' . ($i + 1) . ' has no TAG')
		unless(&is_nonempty($tag));
	&fatal("config error: \[$tag\]: tag not alphanumeric")
		if($tag =~ qr/[^a-zA-Z\d_.\-]/);
	&fatal("config error: \[$tag\]: tag duplicate in mount-points" .
		($tags{$tag} + 1) . ' and ' . ($i + 1)) if(exists($tags{$tag}));
	$tags{$tag} = $i;
	$taglen = length($tag) if(length($tag) > $taglen);
	&fatal("config error: \[$tag\]: no absolute FILE specified")
		unless(&is_abspath($mountpoint->{'FILE'}));
	my $dir = $mountpoint->{'DIR'};
	&fatal("config error: \[$tag\]: no absolute DIR specified")
		unless(defined($dir) && ((ref($dir) eq 'CODE')
			|| &is_abspath($dir)));
	# Compile all regular expressions and transform into arrays:
	for my $j ('SKIP', 'SKIPDIR', 'DIFF', 'FILL') {
		my $a = $mountpoint->{$j};
		unless(defined($a)) {
			$mountpoint->{$j} = [];
			next
		}
		if(ref($a) ne 'ARRAY') {
			if(ref($a) eq 'Regexp') {
				$mountpoint->{$j} = [ $a ]
			} elsif((ref(\$a) eq 'SCALAR') && ($a ne '')) {
				$mountpoint->{$j} = [ qr/$a/ ]
			} else {
				&fatal("config error: \[$tag\]: $j no Regexp or string")
			}
			next
		}
		for my $r (@$a) {
			next if(ref($r) eq 'Regexp');
			&fatal("config error: \[$tag\]: entry in $j no Regexp or string")
				unless((ref(\$r) eq 'SCALAR') && ($r ne ''));
			$r = qr/$r/
		}
	}
}

# Now fill @mounts or %pass_dir, respectively, according to masks:

my @mounts = ();
my %pass_dir = ();

if($pass_dir) {
	for my $i (@ARGV) {
		$pass_dir{$i} = 1 if(&is_abspath($i));
		my $j = abs_path($i);
		$pass_dir{$j} = 1 if(&is_abspath($j))
	}
} else {
	if(@ARGV) {
		for my $i (@ARGV) {
			$i =~ s/([^\w\*\?\[\]])/\\$1/g;
			$i =~ s/\*/.*/g;
			$i =~ s/\?/./g;
			my $reg = qr/^$i$/;
			for my $j (@CFG::mounts) {
				next unless($j->{'TAG'} =~ $reg);
				next if(exists($j->{'DONE'}));
				push(@mounts, $j);
				$j->{'DONE'} = 1
			}
		}
	} else {
		@mounts = @CFG::mounts
	}
	unless(@mounts) {
		&warning('no mount-points selected') unless($quiet);
		exit(0)
	}
}

# Make sure that /run/squashmount exists (unless we have $run_ro)

&make_directory($rundir) unless($run_ro || (-d $rundir));

# Finally, the main loop over the @mounts or %pass_dir entries:

for my $i ($pass_dir ? (@CFG::mounts) : (@mounts)) {
	$user_config = $i;
	$tag = $i->{'TAG'};
	$current_empty = undef;
	$current = {};
	&read_settings();
	&start_locking();
	if($pass_dir) {
		next unless(&find_pass_dir($current, \%pass_dir)
			|| &find_pass_dir($user_config, \%pass_dir))
	}
	my %current_bak = %$current;
	&fill_current();
	&set_globals();
	&bad_status() unless(&{$action}());
	unless($run_ro) {
		unless(&remove_settings() || &hash_equal(\%current_bak, $current)) {
			&bad_status() unless(&write_settings())
		}
	}
	&end_locking();
	last if($firstmatch || $had_error)
}
exit($exitstatus);
