#! /usr/bin/env perl
use strict;
use warnings;
use integer;
use Pod::Usage;
use Getopt::Long;
use File::Compare;
use File::Copy;
use File::Find;
use File::Path qw(make_path remove_tree);
require File::Temp;
use Cwd 'abs_path';

$|=1;

my $name = 'squashmount';

sub version {
	print("$name 2.0\n");
	exit 0
}

=head1 NAME

squashmount - mount certain directories with squashfs + overlayfs/aufs/...

=head1 SYNOPSIS

=over 8

=item B<squashmount> [options] I<command> [I<mask1> I<mask2> ...]

Where I<command> is one of B<mount>, B<umount>, B<remount>, B<set>, B<reset>,
B<status>, B<forget>, B<print->I<...>

=back

To get an extended help, type B<squashmount man>

=head1 DESCRIPTION

For each configured mount-point (resp. if I<mask1>, I<mask2>, ... are given,
for all mount points whose tag match at least one of the regular expressions),
the corresponding directory is mounted readonly using squash as a readonly
filesystem and additionally using overlayfs/aufs/... as a writable filesystem.

When the filesystem is umounted or remounted, the changed data is recompressed
(unless the mount-point is configured otherwise).

Normally, your init-system should call B<squashmount mount> and
B<squashmount umount> on starting and stopping you system, respectively,
so that you data is regularly resquashed.
You can manually get the effect of a restart by calling B<squashmount remount>.

B<squashmount> reads its mount-points from F</etc/squashmount.pl> which is
documented later (the path can be changed with B<--configfile>).

B<squashmount> keeps its current state in F</run/squashmount> (the path
can be changed with B<--rundir>) in a format which may depend on tools used
and which may also change in future versions of B<squashmount>.
(The path F</run/squashmount> can be changed with an option.)
B<squashmount> assumes that its data stored
in F</run/squashmount> and the actually mounted directories coincide, that is,
that they are not mounted/umounted without using B<squashmount> and in
particular, that you do not reboot without cleaning the directory.
Therefore, if you modify F</etc/squashmount.pl>, you must make sure to update
F</run/squashmount>; see the B<stop> and B<forget> commands.

B<squashmount set> can be used to set/unset certain
temporary states for the matching mount-tags into F</run/squashmount> which
will be honoured during umount, stop, restart, or remount.
For example, combining with B<--no-squash> or B<--kill> you can instruct
B<squashmount> to keep or kill the new data without resquashing when
umounting, remounting, or shutting down.
This set is kept until B<squashmount stop> or B<squashmount restart> is
executed (or until F</run> is cleaned by the system e.g. on a reboot).
In particular, this state is unchanged by B<squashmount umount> and
B<squashmount remount>.
To change the state permanently, modify the definition of the mount-tag in
the configuration file F</etc/squashmount.pl> correspondingly and call
B<squashmount reset> to propagate the modification to the running system.

Each I<command> applies to all configured mount-points
(resp. to those selected by the additional B<mask1> B<mask2> ... arguments).
The following values for I<command> are availabe:

=over 8

=item B<mount>

Mount all configured mount-points.

This works only if the corresponding squash-file already exists.
Use B<start> or B<create> instead if you want to create the squash-file
for the first time.

=item B<umount>

Umount all configured mount-points, resquashing if data was changed
(and has reached a configured threshold).
Moreover, the modified data in the CHANGES directory is removed
(the directory is "cleaned").
This command keeps the local setting made with B<quashmount set>
unless the option B<-r> (B<--reset>) is used.

=item B<remount>

This is somewhat like calling B<umount> followed by B<mount>.
This is skipped if it is neither necessary to resquash nor to delete data.
Use B<--force> to omit this skipping.

=item B<create>

This is meant to be used only the first time when a mount-point is used:
It creates the squash-file from the directory DIR specified in the
configuration of that mount-point; afterwards that directory is cleaned.
If the squash-file already exists, you have to use B<--force> (and B<--quiet>
if you want to suppress the corresponding warning).

=item B<start>

This is like B<squashmount mount>, but if there is not yet a squash-file
(that is, presumably only the first time when this mount-point is used),
B<squashmount create> is executed in advance.

=item B<stop>

This is like calling B<squashmount umount> followed by B<squashmount forget>:
After umounting it forgets all corresponding information of B<squashmount set>
for the corresponding mount-points, and moreover, if the configuration uses
temporary directories, new directories will be chosen on the next B<mount>.

In order to change F</etc/squashmount.pl> after B<squasmount mount> was called,
the safe way is to call first B<squashmount stop> (at least for the
mount-points you want to modify) and then do your modifications.

=item B<restart>

This is like calling B<squashmount stop> followed by B<squashmount start>.
Note that in contrast to B<remount> this is executed unconditionally
(and it differs also substantially from B<squashmount --force remount>).

=item B<status> or B<list>

This outputs some general status information, depending on the verbosity level.
To output particular data use the B<print-...> commands (and specify B<mask1>).

=item B<set>

If combined with other options, modify the corresponding active state
of B<--threshold> and B<--kill> in F</run/squashmount>.

=item B<reset>

Undo all effects of a previous B<set> commands for the corresponding
mount-point, according to the current F</etc/squashmount.pl>.

If you change B<THRESHOLD> or B<KILL> for a mount point in
F</etc/squashmount.pl>, use B<squashmount reset> to active this new setting.
For other changes on F</etc/squashmount.pl> see the description of the
B<forget> command.

=item B<forget>

This removes B<all> local configuration stored in F</run/squashmount> for
the corresponding mountpoints. It works only for umounted mountpoints.
(You can use F<--force> to make it work anyway, but this is very dangerous;
see below).

In order to change F</etc/squashmount.pl> after B<squasmount mount> was called,
the safe way is to call first B<squashmount stop>, i.e. B<squashmount umount>
followed by B<squasmount forget> (at least for the mount-points you want to
modify) and only then do your modification.

If you shortcut this (e.g. because you forgot calling B<squashmount stop>
in advance or because you cannot umount currently some reason) you have to
know more details: Changes to B<BACKUP> become immediately active.
All other changes get ignored; changes to B<THRESHOLD> or
B<KILL> can be made active by using B<squashmount reset>.
With this knowledge you should be able to call B<squashmount stop> even
after you made your changes.

If you plan to use B<forget> with the B<--force> flag on a mounted mount-point,
you must know what you are doing: B<squasmount> is then no longer aware that
the correspondig mount-point is actually mounted; you are then responsible
for umounting these mount-points without using B<squashmount>.

=item B<print-tag>

Output the tag.
This is mainly useful to get a list of all tags if you do not specify a mask.

=item B<print-dir>

Output the name of the directory B<DIR> of the specified mount-point(s).

=item B<print-readonly>

Output the effective B<READONLY> directory.
Output B<1> if the mount-point is configured to be non-writable.

=item B<print-changes>

Output the effective B<CHANGES> directory in which the modified data is stored.
This is empty if the mount-point is configured to be non-writable.

=item B<print-file>

Output the absolute path to the squash-file.

=item B<print-type>

Output the tool actually used for mounting.
Possible output is C<overlayfs>, C<aufs>, C<unionfs-fuse>, C<unionfs>,
C<funionfs>, C<bind>, or C<readonly>.

=item B<print-new>

Output 1 if there is new (i.e. modified) data.

=item B<print-will-squash>

Output 1 whether data will be resquashed on the next umount/remount
according to current setting and data.

=item B<print-threshold>

Output the currently active threshold value.
Every negative value is normalized to B<-1>.

=item B<print-kill>

Output 1 if B<--kill> is active.

=item B<help>

Print a brief help.

=item B<man>

Show an extended help as a manpage.

=back

=head1 OPTIONS

=over 8

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Display extended help as a manpage.

=item B<--verbose> or B<-v> (accumulative)

Verbose output.

=item B<--squash-verbose=>I<level>

Determines how verbose mksquash is called.
The following I<level> values are available:

=over 16

=item B<0>:
Redirect stdout of B<mksquashfs> to F</dev/null> and use B<-no-progress>

=item B<1> (or anything else than B<0> and B<2>):
Redirect stdout of B<mksquashfs> to F</dev/null>.
You might want to apply a patch for B<mksquashfs> to redirect the progress bar
to stderr: This produces the nicest output with no redundant information.

=item B<2>:
Call B<mksquashfs> without additional options or redirections.

=back

The default I<level> is user-specified in F</etc/squashmount.pl>;
if not specified there the default is B<1>.

=item B<--quiet> or B<-q> (accumulative)

Quiet output.

=item B<--version> or B<-V>

Print version number and exit

=item B<--config>B<=>I<file> or B<-c> I<file> (accumulative)

Using I<file> instead of B</etc/squashmount.pl> as a config file.
If this option is repeated, all passed B<file>s are parsed in the given order.

=item B<--rundir=>I<dir>

Using I<file> instead of B</run/squashmount>.

=item B<--interactice> or B<-i>

Ask for confirmation before cleaning a directory.

=item B<--no-squash> or B<--nosquash> or B<-n>

(This is an alias for B<--threshold=-1>.)
If used with B<umount> or B<remount> do not resquash the directories and
keep the new data.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if filesystem was correspondingly
configured (without actually changing the configuration, of course).

=item B<--squash> or B<-s>

(This is an alias for B<--threshold=0> which is normally the default.)
If used with B<umount> or B<remount> squash the directories if they have
been changed.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if filesystem was correspondingly
configured (without actually changing the configuration, of course).

=item B<--threshold=>I<size> or B<-t> I<size>

For negative I<size> act as described for B<--no-squash>, and for zero I<size>
act as described for B<--squash>.

For positive I<size>, if the length of the changes is less than I<size> bytes,
squashmount will act with B<umount> as if B<--no-squash> is active, otherwise
it acts normally, that is, the data is resquashed.

For convenience, you can append B<k>, B<m>, B<g>, B<t> to the number to denote
kilobytes (1024), megabytes (1024^2), gigabytes (1024^3),
or terrabytes (1024^4), respectively.

For the particular case that I<size> is empty the value of the current
F</etc/squashmount.pl> is taken (cf. the B<unset> command).
This is useful B<set> has been used:

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if filesystem was correspondingly
configured (without actually changing the configuration, of course).

=item B<--kill> or B<-k>

When umounting/remounting do not resquash the data but delete all new data.
Use with care!
For safety reasons, this has no effect if the currently active B<--threshold>
values is negative.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if filesystem was correspondingly
configured (without actually changing the configuration, of course).

=item B<--no-kill> or B<--nokill> or B<-K>

Remove the effect of B<--kill>.

If used with B<set>, set the state in F</run/squashmount>
so that this happens for all subsequent umounts/remounts.

If used with B<status> or B<print*> act as if filesystem was correspondingly
configured (without actually changing the configuration, of course).

=item B<--reset> or B<-r>

After umounting, reset the data changed with the B<set> command according
to the current configuration in F</etc/squashmount.pl>

=item B<--force> or B<-f>

If used with B<remount> do not skip remounting, even if it is not
necessary to resquash or to delete data.

If used with B<create>, continue even if the squash-file already exists.

If used with B<forget>, forget information also if mountpoint is mounted.
The latter is very dangerous, see the description of the B<forget> command.

=item B<--lazy>

When umounting fails, attempt also lazy umounting.

=item B<--no-lazy> or B<--nolazy>

Do not attempt lazy umounting when normal umounting failed.
Whether B<--lazy> or B<--no-lazy> is the default depends on F</etc/squashmount.pl>;
if not specified there the default is B<--lazy>.

=item B<--threshold=>I<size> or B<-t> I<size>

This is analogous to B<--keep> but will avoid the resquashing only if
there is less that I<size> bytes changed on disk.
(You can append B<k> or B<m> to I<size> to denote multiples of 1024 or 1024^2,
respectively.)
A negative number is equivalent to B<--keep>.
If I<size> is empty the value configured from F</etc/squashmount.pl> is taken.

=item B<--separator=>I<sep> or B<-S> I<sep>

When using B<print-...>, I<sep> is appended to the output of each mountpoint.
The default is a newline.

=item B<--pass-directory>

When this option is used, the passed arguments I<mask1> I<mask2> ... are
interpreteted as names of mounted readonly or writable directories.
This is to allow this script to be used as a callback from umount-wrappers
like /sbin/umount.overlayfs or /sbin/umount.squashfs

=item B<--title=>I<options> or B<-T> I<options>

Here I<options> is some of the letters:
The corresponding option(s) are passed to the title script to set the
hardstatus title. This option can be used accumulatively.
If at least one passed option is B<->, the title script is not used.

=item B<--error> or B<-e>

Do not process further mount points when an error occurs.

=item B<--no-error> or B<--noerror> or B<-E>

Do not break on errors (default)

=item B<--first> or B<-1>

Only execute the first match, then end.

=item B<-->

Last option

=back

=head1 F</etc/squashmount.pl>

The file F</etc/squashmount.pl> can be any perl code which fills
the array B<@dirs> with references to hashes; one hash for every tag.
In addition, the array B<@order> can be filled with the available tools
and the order in which they should be tried.
Also the default variables $B<$lazy> and B<$squash_verbose> can be initialized.
Here is an example for this file
(actually, a different syntax is recommended, see the remarks at the
end of this manpage):

=over 8

=item $lazy = 1;

=item $squash_verbose = 1;

=item @order = ('overlayfs', 'aufs', 'unionfs-fuse', 'unionfs', 'funionfs');

=item push(@mounts, {

=over 16

=item TAG => 'useless_minimal',

=item DIR => '/usr/local',

=item FILE => '/usr/local.sqfs',

=back

=item }, {

=over 16

=item TAG => 'guest',

=item DIR => '/home/guest'

=item FILE => '/home/guest-skelton.sqfs'

=item KILL => 1 # Forget all changes when umounting

=back

=item }, {

=over 16

=item TAG => 'tex',

=item DIR => '/usr/share/texmf-dist',

=item FILE => '/usr/share/texmf-dist.sqfs',

=item CHANGES => '/usr/share/texmf-dist.changes',

=item READONLY => '/use/share/texmf-dist.readonly',

=item SKIP => '^ls-R$',

=item DIFF => '^tex(/generic(/config(/language(\.(dat(\.lua)?|def)))?)?)?$'

=back

=item }, {

=over 16

=item TAG => 'portage',

=item DIR => '/usr/portage,

=item FILE => '/usr/portage.sqfs',

=item CHANGES => '/usr/portage.changes',

=item READONLY => '/usr/portage.readonly',

=item THRESHOLD => '40m' # resquash on umount if 40 megabytes changed

=back

=item }, {

=over 16

=item TAG => 'fancy_temporary',

=item DIR => sub { return File::Temp::newdir() },

=item CHANGES => sub { return File::Temp::newdir(undef, DIR = '/path/to/ramdisk') },

=item READONLY => \&make_temporary_subdir,

=item FILE => '/just/a/crazy/example.sqfs',

=item SKIPDIR => [ '(^|/)temp', qr{(^|/)tmp}i ], # temp* TMP* ...

=item SKIPFUNC => sub { my ($rel, $abs, $ro) = @_; return (-d $abs) }

=back

=item });

=item sub make_temporary_subdir { my ($tag) = @_;

=over 16

=item my $dir = File::Temp::newdir(undef, CLEANUP => '')->dirname;

=item # CLEANUP => '' is crucial since we return only a string!

=item $dir .= "/$tag"; mkdir($dir); return $dir }

=back

=back

Except for B<@mounts>, the meaning of the variables is easily explained:

=over 8

=item B<$lazy>

This determines whether B<--lazy> or B<--no-lazy> is the default.
If this variable is not specified the true value B<1> is chosen.

=item B<$squash_verbose>

This is the default if B<--squash-verbose> is not specified.
If this variable is not specified the value B<1> is chosen.

=item B<@order>

This array determines in which order the overlayfs/aufs/... tools are tried.
The first successful tool is chosen, and if all fail, B<mount --bind> is used.
If not modified, this array defaults to

=over 16

=item ('overlayfs', 'aufs', 'unionfs-fuse', 'unionfs', 'funionfs')

=back

These defaults contain all tools supported by B<squashmount>.

=back

The array B<@mounts> defines the various mount-points.
The first mount-point in the above example is the minimal data which
has to be specified for a mount-point.
However, typically you should also specify at least the keys B<CHANGES> and
usually also B<READONLY> unless you have a special reason not to.
The following keys are supported:

=over 8

=item B<TAG>

A unique identifier:
The B<TAG> is matched against the I<mask> entries on the command line.
The content must be alphanumeric; only the symbols . - _ are allowed.

=item B<DIR>

The absolute path of the main directory which you want to squash.

Alternatively, B<DIR> can be a functin reference which returns a string to
the directory or alternatively a File::Temp::Dir object.
This function is executed only once if B<DIR> is unknown and in this case
it gets passed the tag as an argument.
The intention is that this function can be used to return e.g. a temporary
dirname by using something like as in the B<fancy_temporary> example above.

Be aware that if this function uses File::Temp::newdir, it should pass
C<CLEANUP => ''> to avoid that the directory is magically removed recursively:
Forgetting this can severly damage your data!

As an exception, if the function returns the corresponding created object
(and not only a filename as in the C<make_temporary_subdir> example above),
B<squashmount> will care about disabling B<CLEANUP> automatically.
For this reason, we had lazily avoided C<CLEANUP => ''> in some places
in the above B<fancy_temporary> example when calling B<File::Temp::newdir>.

If you use a temporary directory, you can find the actual path with
B<squashmount -q --directory status ...>.

=item B<FILE>

The absolute path to the squash-file which contains the actual data.

=item B<CHANGES>

The directory into which the changes to B<DIR> are stored.
If B<CHANGES> is not specified then a temporary directory is created
and used instead.

The same rules as for B<DIR> hold, that is, you can also pass a function which
explicitly calls File::Temp::newdir with appropriate data.

Note that using a temporary directory may be dangerous since if temporary
directories are cleaned on boot this means that modifications to B<DIR>
are lost if they are not (successfully) squashed on shutdown
(e.g. due to option B<--keep>).
If you use a temporary directory, you can find the actual path with
B<squashmount -q --changes status ...>.

=item B<READONLY>

If this is nonempty but not an absolute path, then B<DIR> is mounted readonly.
If this is an absolute path then a readonly version of the content of B<DIR>
is mounted here.
It is not possible to omit this directory if B<DIR> should be writable.
For the special case that B<READONLY> is empty, a temporary directy is used.

The same rules as for B<DIR> hold, that is, you can also pass a function which
explicitly calls File::Temp::newdir with appropriate data.

If you use a temporary directory, you can find the actual path with
B<squashmount -q --changes status ...>.

=item B<THRESHOLD>

This is the threshold value used for that mount-point
(unless changed by command line options).
Set it to a negtive value for an infinite threshold,
that is, to get the effect of B<--no-squash>.
The default is B<0>.

=item B<KILL>

If true (nonempty and not 0) B<--kill> is active for that mount-point
(unless changed by command line options).

=item B<MKSQUASHFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when calling mksquashfs.
The option B<-noappend> is used automatically.
Depending on B<$squashfs_verbose> and B<COMPRESSION> also the options
B<-comp> or B<-no-progress> are appended automatically.

=item B<MOUNT_OVERLAYFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with overlayfs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_AUFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with aufs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_UNIONFS_FUSE>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with unionfs-fuse.
The default is B<['-o', 'cow'. '-o', 'allow_other', '-o', 'use_ino',
'-o', 'nonempty', '-o', 'noatime', '-o', 'hide_meta_files']>.

=item B<MOUNT_UNIONFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with unionfs.
The default is B<['-o', 'noatime']>.

=item B<MOUNT_FUNIONFS>

This should be a (possibly empty) string or a reference to an array of strings:
These strings are used as additional options when mounting with funionfs.
The default is B<['-o', 'allow_other', '-o', 'nonempty']>.

=item B<COMPRESSION>

Specifies the compression mode for B<mksquashfs>:
The available values depend on the installed version of B<mksquashfs>;
typically B<xz>, B<lzma>, B<gzip>, B<lzo> are available
(with B<xz> being the slowest but best in compression ratio).
If the value is empty, no B<-compression> parameter is passed,
that is, the default of the installed B<mksquashfs> is chosen.
If B<COMPRESSION> is not explicitly set or undefined, the value B<xz> is used.

=item B<BACKUP>

If this is set to an absolute path, then when resquashing B<FILE>,
a copy of the old version is moved to that path.
If the file B<BACKUP> already exists, it is removed.

If B<BACKUP> is not an absolute path but nonempty, the path is that of
B<FILE> with the string C<.bak> appended.

=item B<TEMPDIR>

The new version of the squashed data is first created in a temporary file.
If B<TEMPDIR> is set it is created in this directory.
It is useful to choose a directory on a harddisk if the regular temporary
directory is a ramdisk with less space than the expected filesize.
If you choose a harddisk, things will be faster if you choose the same
partition on which the squash-file B<FILE> resides.

=item B<BLOCKSIZE>

The size of one disk-block when calculating the changed data for the threshold.
The default is 4096.
The blocksize does not have to be in relation with the physical blocksize.
For instance, if you a directory with small files, it might be a good idea
to set B<BLOCKSIZE> to a huge value so that the calculation for the
threshold is essentially based on the number of files (instead of their size).

=item B<SKIP>

This is a regular expression (or a string representing a regular expression)
or a reference to an array of such strings/regular expressions.
For each file/directory in B<CHANGES> its path (relative to B<CHANGES>) is
matched against these regular expressions.
If the file matches, it is not considered as being changed.
This is useful to avoid squashing only because e.g. a known temporary
file has changed in this directory which you do not care about.

When all changes are skipped during umounting, the B<CHANGES> directory is
cleaned anyway, i.e. skipping a file means that changes to this file are
usually lost!

If a file you want to skip resides in a subdirectory (not in the root
of B<CHANGES>) you probably also skip all parent directories.
However, to be more careful you might want to do this with B<DIFF>
(as that will check that it is really a directory).

=item B<SKIPDIR>

This is similar to B<SKIP>, but only for directories; moreover, also the
whole content of matching directories is being considered as unchanged.

If you want to B<SKIPDIR> a directory lying not in the root, of B<CHANGES>
you will probably want to include its parent directories to B<DIFF>
(or to B<SKIP> if you are less careful).

=item B<DIFF>

This is similar to B<SKIP>, but a little bit more careful:
The file/directory is only considered unchanged if it is the same as the
corresponding file in the B<READONLY> directory, up to possibly
permissions or time stamps.
This is to avoid resquashing just because some timestamps or permissions
were changed.

As for B<SKIP> and B<SKIPDIR>, for files in subdirectories you will probably
also want to include the parent directories here.
As an example, to ignore changes only in timestamps or permissions of
the files

=over 16

=item F<tex/generic/config/language.dat>

=item F<tex/generic/config/language.dat.lua>

=item F<tex/generic/config/language.def>

=back

you must also ignore that the corresponding parends are created in CHANGES.
Therefore, in the example file above (in TAG tex), the regular expression
in B<DIFF> not only matches the above files but also their parent directories.

To match for files, it might be convenient to use several regular expressions
(or strings): All related variables B<SKIP>, B<SKIPDIR>, B<DIFF> accept also
references to arrays of regular expressions. See e.g. B<SKIPDIR> in
in the fancy_temporary example above.
Note in that example also that you can can pass regular expressions
instead of strings. This way you can pass e.g. perl flags to ignore case.

=item B<SKIPFUNC>

This is the most generic form of B<SKIP>, B<SKIPDIR>, B<DIFF>:
This is a reference to a function which can decide whether the file is being
considered as changed.
The function gets passed three parameters: The relative filename,
the absolute filename, and the corresponding pathname in the READONLY directory.
The function must return a true value (e.g. 1) if the file should not be
considered as changed.
If the function sets C<$File::Find::prune = 1> in case of a directory
then its content is not considered as changed, either.

In the above B<fancy_temporary> example, this functions is used to ignore all
added/modified (empty) directories.

=back

Note that F</etc/squashmount.pl> is ordinary perl code, so you can use
perl e.g. to source other files at your discration.
Moreover, you are not restricted to the syntax of the above example.
In fact, to simplify filling hash references for typical usage, some functions
are provided by B<squashmount> when F</etc/squashmount.pl> is parsed:

=over 8

=item B<&standard_mount(>I<tag>B<,> I<dir> I<...> B<)>

This function returns a reference to a hash with the keys B<TAG> and B<DIR>
filled according to the first two arguments.
In addition, the values for the keys B<CHANGES>, B<READONLY>, and B<FILE>
are generated by just appending C<.changes>, C<.readonly>, C<.sqfs> to I<dir>.
Moreover, if I<...> are references to hashes, they are added to the hash:
Later hashes override earlier ones; setting a value to C<undef> in a sense
cancels a previous definition.

=item B<&added_hash(>I<hash_reference>B<,> I<hash_reference>B<,> ...B<)>

This function returns a reference to a hash which adds all passed hashes,
that is, it is like B<&standard_mount> except that it does not fill a
hash with certain values first.

=back

Here is an example how to use this to specify the portage mount-point from
the above example and additionally a "standard" mount point (analogously
to the portage mount-point but with different paths and without the
B<THRESHOLD> option) in a shorter way:

=over 8

=item push(@mounts,

=over 16

=item &standard_mount('portage, '/usr/portage', {

=over 24

=item THRESHOLD => '40m'

=back

=item }),

=item &standard_mount('kernel', '/usr/src')

=back

=item );

=back

It is recommended to use a perl variable like B<$defaults> to contains
a reference to a hash with data which you want to specify for practically
every mount-point like B<COMPRESSION> or B<TEMPDIR> and to add this
variable to every point-mount.
This way you can easily change the defaults without manipulating every
mount-point entry manually. (You can still override $defaults
for particular mount points at your discretion.)
Here is such an example which also demonstrates the use of B<&added_hash>:

=over 8

=item my $tempdir = { TEMPDIR => '/my/ramdisk' };

=item my $always = { COMPRESSION => 'gzip', THRESHOLD => '20m' };

=item my $defaults = &added_hash($always, { BACKUP => 1 }, $tempdir);

=item push(@mounts,

=over 16

=item &standard_mount('kernel', '/usr/src', $defaults),

=item &standard_mount('games' '/usr/share/games', $defaults, {

=over 24

=item READONLY => undef # cancel standard definition

=back

=item )}

=back

=item );

=back

=head1 COPYRIGHT AND LICENSE

Copyright Martin VE<auml>th.
This program is under the BSD License.

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Default for the Options:

my @title = ();
my $verbose = 0;
my $quiet = 0;
my $squash_verbose = undef;
my $lazy = undef;
my $force = '';
my $reset = '';
my $interactive = '';
my $opt_threshold = '';
my $opt_kill = undef;
my $pass_directory = '';
my $errorbreak = '';
my $firstmatch = '';
my @configs = ();
my $separator = "\n";
my $rundir = '/run/squashmount';
my $titleopt;

# Global/State variables:

my $current = undef;    # current configuration in /run/squashmount
my $user_config = undef;# current configuration in /etc/squashmount.pl
my $tag = '';           # $user_config->{'TAG'}
my $printed_title = ''; # Have we printed a statusline?
my $taglen;             # Length of the longest tag
my $threshold;          # currently active threshold (integer)
my $kill;               # currently active kill (boolean)

#
# Commands
#

sub cmd_mount {
	return &mount_main('')
}

sub cmd_umount {
	return '' if(&error_unless_mounted());
	return &umount_main(undef, undef)
}

sub cmd_remount {
	return '' if(&error_unless_mounted());
	my ($will_squash, $will_remove) = &check_squash($threshold, $kill);
	unless($force || $will_squash || ($will_remove > 0)) {
		&info('remounting appears unnecessary');
		return 1
	}
	&title("$tag remount") if($printed_title);
	return '' unless(&umount_main($will_squash, $will_remove));
	return &mount_main('');
}

sub cmd_create {
	return '' if(&error_if_mounted());
	my $squashfile = &get_squashfile();
	if(-f $squashfile) {
		if($force) {
			&warning("squashfile $squashfile already exists") unless($quiet);
		} else {
			&error("squashfile $squashfile already exists");
			return ''
		}
	}
	return '' unless(&create_dir('DIR', 1));
	return(&first_create($squashfile, $current->{'DIR'}))
}

sub cmd_start {
	return &mount_main(1)
}

sub cmd_stop {
	if(&error_unless_mounted()) {
		&forget_settings();
		return ''
	}
	return '' unless(&umount_main());
	return &forget_settings()
}

sub cmd_restart {
	my $ret;
	if(&error_unless_mounted()) {
		$ret = ''
	} else {
		return '' unless(&umount_main());
		$ret = 1
	}
	return '' unless(&forget_settings());
	return &mount_main(1);
}

sub cmd_forget {
	unless($force || !&is_nonempty($current->{'MOUNT_DIR'})) {
		&error('mounted, forget is not used');
		return ''
	}
	return &forget_settings()
}

sub cmd_set {
	$current->{'THRESHOLD'} = $threshold;
	$current->{'KILL'} = $kill;
	return 1
}

sub cmd_reset {
	return &reset_main(!$quiet)
}

sub cmd_status {
	&print_header();
	my $type = undef;
	if(&is_nonempty($current->{'MOUNT_DIR'})) {
		$type = $current->{'TYPE'}
	}
	if(&is_resquash_type($type)) {
		my $human = &human_threshold($threshold);
		if($verbose) {
			&print_status_first($type)
		} else {
			&print_status_first(${type} . (' ' x (5 - length($human)))
				. "(${human})")
		}
		my ($newdata, undef) = &check_squash($kill ? 0 : $threshold, '');
		if($newdata) {
			&print_status($kill ?
				'will kill modifications' :
				'will resquash modifications')
		} elsif($kill) {
			&print_status(
				'will kill, but yet unmodified')
		} else {
			my ($nonempty, undef) = &check_squash(0, '');
			&print_status($nonempty ?
				'modified, but will not resquash' :
				'unmodified')
		}
		if($verbose) {
			&print_status('threshold ' .
				(($verbose > 1) ? "$threshold" : $human));
		}
	} else {
		&print_status_first($type ? $type : 'not mounted')
	}
	unless($verbose > 1) {
		&print_status_end();
		return 1
	}
	for my $i ('DIR', 'READONLY', 'CHANGES', 'FILE') {
		my $p = $current->{$i};
		next unless(&is_abspath($p));
		&print_status("$i: $p")
	}
	&print_status_end();
	return 1
}

sub cmd_print_tag {
	&print_header() if($verbose);
	return &do_print($tag)
}

sub cmd_print_dir {
	&print_header() if($verbose);
	return &do_print($current->{'DIR'})
}

sub cmd_print_readonly {
	&print_header() if($verbose);
	return &do_print($current->{'READONLY'})
}

sub cmd_print_changes {
	&print_header() if($verbose);
	return &do_print($current->{'CHANGES'})
}

sub cmd_print_file {
	&print_header() if($verbose);
	return &do_print($current->{'FILE'})
}

sub cmd_print_type {
	&print_header() if($verbose);
	return &do_print($current->{'TYPE'})
}

sub cmd_print_new {
	&print_header() if($verbose);
	my $changes = $current->{'CHANGES'};
	return '' unless(&is_abspath($changes));
	my ($will_squash, undef) = &check_squash(0, '');
	return &do_print($will_squash ? '1' : '')
}

sub cmd_print_will_squash {
	&print_header() if($verbose);
	my $changes = $current->{'CHANGES'};
	return '' unless(&is_abspath($changes));
	my ($will_squash, undef) = &check_squash($threshold, $kill);
	return &do_print($will_squash ? '1' : '')
}

sub cmd_print_threshold {
	&print_header() if($verbose);
	return &do_print($threshold)
}

sub cmd_print_kill {
	&print_header() if($verbose);
	return &do_print($kill ? '1' : '')
}

#
# Functions
#

# The main start/mount function:

sub mount_main {
	my ($first_create) = @_;
	if(&is_nonempty($current->{'MOUNT_DIR'})) {
		my $dir = $user_config->{'DIR'};
		&error('already mounted DIR');
		return ''
	}
	my $squashfile = &get_squashfile();
	if(-f $squashfile) {
		$first_create = ''
	} elsif(!$first_create) {
		&error("squashfile $squashfile not found");
		return ''
	}
	return '' unless(&create_dir('DIR', 1));
	my $dir = $current->{'DIR'};
	if($first_create) {
		return '' unless(&first_create($squashfile, $dir))
	}
	$current->{'FILE'} = abs_path($squashfile);
	my $ro_stat = &create_dir('READONLY', '');
	return '' unless($ro_stat);
	&info('mounting...') unless($quiet);
	if($ro_stat < 0) {
		return '' unless(&mount_squash($squashfile, $dir));
		$current->{'MOUNT_DIR'} = 1;
		$current->{'TYPE'} = 'readonly';
		$current->{'CHANGES'} = '';
		return 1
	}
	my $dir_ro = $current->{'READONLY'};
	if($current->{'MOUNT_RO'}) {
		&warning("have mounted READONLY $dir_ro")
			unless($quiet > 1)
	} else {
		return '' unless(&mount_squash($squashfile, $dir_ro));
		$current->{'MOUNT_RO'} = 1
	}
	return '' unless(&create_dir('CHANGES', 1));
	my $type = &mount_rw($dir_ro, $dir, $current->{'CHANGES'});
	return '' unless(defined($type));
	$current->{'MOUNT_DIR'} = 1;
	$current->{'TYPE'} = $type;
	return 1
}

# The main umount function.
# $will_squash and $will_remove will be calculated if they are undef

sub umount_main {
	my ($will_squash, $will_remove) = @_;
	($will_squash, $will_remove) = &check_squash($threshold, $kill)
		unless(defined($will_squash) && defined($will_remove));
	my $created = '';
	my $tempfile;
	my $dir = $current->{'DIR'};
	if($will_squash) {
		&info('squashing (this may take a while)') unless($quiet);
		my $tempdir = $user_config->{'TEMPDIR'};
		if(&is_abspath($tempdir)) {
			$tempfile = File::Temp->new(DIR => $tempdir)
		} else {
			$tempfile = File::Temp->new();
		}
		return '' unless(&mksquashfs($tempfile->filename, $dir, $squash_verbose));
		$created = 1
	}
	&info('umounting...') unless($quiet);
	return '' unless(&umount_dir($dir));
	$current->{'MOUNT_DIR'} = '';
	&reset_main(!$quiet) if($reset);
	if($current->{'MOUNT_RO'}) {
		my $dir_ro = $current->{'READONLY'};
		return '' unless(&umount_dir($dir_ro));
		$current->{'MOUNT_RO'} = ''
	}
	if($created) {
		my $squashfile = $current->{'FILE'};
		my $backup = $user_config->{'BACKUP'};
		if(&is_nonempty($backup)) {
			$backup = $squashfile . '.bak'
				unless(&is_abspath($backup));
			&info("$squashfile -> $backup") unless($quiet);
			unlink($backup);
			unless(move($squashfile, $backup)) {
				&error("failed moving $squashfile to $backup");
				return ''
			}
		}
		&info("tempfile -> $squashfile") unless($quiet);
		unlink($squashfile);
		$tempfile->unlink_on_destroy('');
		unless(move($tempfile->filename, $squashfile)) {
			&error("failed moving tempfile to $squashfile");
			return ''
		}
	}
	delete $user_config->{'TYPE'};
	return 1 unless($will_remove);
	my $changes = $current->{'CHANGES'};
	&title("$tag cleaning");
	&info('cleaning directory...') unless($quiet);
	return &clean_directory($changes)
}

# The main reset function.

sub reset_main {
	my ($message) = @_;
	&info('resetting configuration') if($message);
	return &fill_current(1)
}


# print an error and return 1 if not mounted

sub error_unless_mounted {
	unless(&is_nonempty($current->{'MOUNT_DIR'})) {
		&error('DIR was not mounted');
		return 1
	}
	return ''
}

# print an error and return 1 if mounted

sub error_if_mounted {
	if(&is_nonempty($current->{'MOUNT_DIR'})) {
		&error('already mounted DIR on ' . $current->{'DIR'});
		return 1
	}
	return ''
}

# This function is called for the first creation of the squash-file

sub first_create {
	my ($squashfile, $dir) = @_;
	&info('It seems this is mounted for the first time:',
		"The squashed file $squashfile does not exist yet;",
		"it will be initialized now from $dir") unless($quiet);
	return '' unless(&mksquashfs($squashfile, $dir, 2));
	&info('cleaning original content') unless($quiet);
	return &clean_directory($dir)
}

# The main function to mount read-writable. Returns type or undef

sub mount_rw {
	my ($ro, $rw, $changes) = @_;
	for my $i (@CFG::order) {
		if($i =~ qr/overlay/i) {
			return 'overlayfs' if(&mount_overlayfs($ro, $rw, $changes))
		} elsif($i =~ qr/aufs/i) {
			return 'aufs' if(&mount_aufs($ro, $rw, $changes))
		} elsif($i =~ qr/fuse/i) {
			return 'unionfs-fuse' if(&mount_unionfs_fuse($ro, $rw, $changes))
		} elsif($i =~ qr/funion/i) {
			return 'funionfs' if(&mount_funionfs($ro, $rw, $changes))
		} else { # ($i =~ qr/union/i)
			return 'unionfs' if(&mount_unionfs($ro, $rw, $changes))
		}
	}
	&error('fallback to mount --bind');
	return (&mount_bind($ro, $rw) ? 'bind' : undef)
}

# Mount with overlayfs:

sub mount_overlayfs {
	my ($ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_OVERLAYFS'},
		['-o', 'noatime']);
	return 1 if(system('mount', '-t', 'overlayfs', @options,
		'-o', "upperdir=${changes}", '-o', "lowerdir=${ro}",
		'--', 'overlayfs', $rw) == 0);
	&warning('overlayfs failed') unless($quiet > 1);
	return ''
}

# Mount with aufs:

sub mount_aufs {
	my ($ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_AUFS'},
		['-o', 'noatime']);
	$ro =~ s/([=:])/\\$1/g;
	$changes =~ s/([=:])/\\$1/g;
	return 1 if(system('mount', '-t', 'aufs', @options,
		'-o', "br:${changes}=rw:${ro}=rr", '--', 'aufs', $rw) == 0);
	&warning('aufs failed') unless($quiet > 1);
	return ''
}

# Mount with unionfs-fuse

sub mount_unionfs_fuse {
	my ($ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_UNIONFS_FUSE'},
		['-o', 'cow'. '-o', 'allow_other', '-o', 'use_ino',
		'-o', 'nonempty', '-o', 'noatime', '-o', 'hide_meta_files']);
	$ro =~ s/([=:])/\\$1/g;
	$changes =~ s/([=:])/\\$1/g;
	return 1 if(system('unionfs', @options,
		'-o', "br:${changes}=RW:${ro}=RO", $rw) == 0);
	&warning('unionfs-fuse failed') unless($quiet > 1);
	return ''
}

# Mount with unionfs

sub mount_unionfs {
	my ($ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_UNIONFS'},
		['-o', 'noatime']);
	$ro =~ s/([=:])/\\$1/g;
	$changes =~ s/([=:])/\\$1/g;
	return 1 if(system('mount', '-t', 'unionfs', @options,
		'-o', "br:${changes}=rw:${ro}=ro", '--', 'unionfs', $rw) == 0);
	&warning('unionfs failed') unless($quiet > 1);
	return ''
}

# Mount with funionfs

sub mount_funionfs {
	my ($ro, $rw, $changes) = @_;
	&push_ref(\my @options, $user_config->{'MOUNT_FUNIONFS'},
		['-o', 'allow_other', '-o', 'nonempty']);
	$ro =~ s/\=/\\\=/g;
	return 1 if(system('funionfs', $changes, $rw, @options,
		'-o', "dirs=${ro}=ro") == 0);
	&warning('funionfs failed') unless($quiet > 1);
	return ''
}

# Mount with bind:

sub mount_bind {
	my ($from, $to) = @_;
	return 1 if(system('mount', '--bind', '--', $from, $to) == 0);
	&error('mount --bind failed');
	return ''
}

# Mount the squash-file readonly:

sub mount_squash {
	my ($squashfile, $dir) = @_;
	return 1 if(system('mount','-t', 'squashfs',
		'-o', 'loop,ro,noatime', '--', $squashfile, $dir) == 0);
	&error('failed to mount squashfile');
	return ''
}

# Create the squash file:

sub mksquashfs {
	my ($squashfile, $dir, $squash_verbose) = @_;
	my @options = ('-noappend');
	push(@options, '-no-progress') if($squash_verbose == 0);
	my $compression = $user_config->{'COMPRESSION'};
	$compression = 'xz' unless(defined($compression));
	push(@options, '-comp', $compression) if($compression ne '');
	&push_ref(\@options, $user_config->{'MKSQUASHFS'}, undef);
	&title("$tag squashing");
	my $oldout = undef;
	if($squash_verbose != 2) {
		open($oldout, '>&', \*STDOUT) && open(STDOUT, '>', '/dev/null')
	}
	my $ret = (system('mksquashfs', $dir, $squashfile, @options) == 0);
	open(STDOUT, '>&', $oldout) if(defined($oldout));
	return $ret
}

# Umount the directoy, possibly lazily:

sub umount_dir {
	my ($dir) = @_;
	my $oldout = undef;
	open($oldout, '>&', \*STDOUT) && open(STDOUT, '>', '/dev/null');
	my $ret = (system('umount', '--', $dir) == 0);
	unless($ret) {
		if($lazy) {
			&error('non-lazy umount failed,',
				"using lazy umount of $dir") unless($quiet > 1);
			$ret = (system('umount', '-l', '--', $dir) == 0);
			&error("lazy umount failed: $dir")
				unless($ret);
		} else {
			&error('non-lazy umount failed');
		}
	}
	open(STDOUT, '>&', $oldout) if(defined($oldout));
	return $ret
}

# Check whether squashing is necessary, taking $current and options into account
# Returns ($will_squash, $will_remove).
# $will_remove = -1 denotes cleaning a presumably empty directory.

sub check_squash {
	my ($threshold, $kill) = @_;
	my $type = $current->{'TYPE'};
	return ('', 0) if(($threshold < 0) || !&is_resquash_type($type));
	return ('', 1) if($kill);
	my $thr = &threshold_dir($threshold, $type);
	return ('', -1) if($thr == 0); # clean "empty" directory
	return (1, 1) if($thr > 0);
	return ('', 0)
}

# The main function to read a configuration file:

# The default config must be parsed before the function
{
	package CFG;
	our $lazy = 1;
	our $squash_verbose = 1;
	our @order = ('overlayfs', 'aufs', 'unionfs-fuse', 'unionfs', 'funionfs');
	our @mounts = ();
}

sub read_config_file {
	my ($file) = @_;
	$file = abs_path($file);
	unless(-f $file) {
		&warning("skipping config file $file (not a file)") unless($quiet);
		return
	}
	&info("reading config file $file") if($verbose > 2);
	package CFG;
	our $lazy;
	our $squash_verbose;
	our @order;
	our @mounts;
	sub standard_mount {
		my ($tag, $dir, @rest) = @_;
		return &added_hash({
			TAG => $tag,
			DIR => $dir,
			CHANGES => $dir . '.changes',
			READONLY => $dir . '.readonly',
			FILE => $dir . '.sqfs',
		}, @rest)
	}
	sub added_hash {
		my $a = {};
		for my $i (@_) {
			for my $j (keys(%$i)) {
				$a->{$j} = $i->{$j}
			}
		}
		return $a
	}
	unless(my $ret = do($file)) {
		die "error parsing $file: $@\nstopped" if($@);
		die "error running $file\nstopped" if(defined($ret) && !$ret)
	}
}

# Read settings from /run/squashmount:

sub read_settings {
	my $file = $rundir . '/' . $tag;
	{
		package RUNCFG;
		our %data = ();
		do($file) if(-r $file);
	}
	%$current = %RUNCFG::data;
}

# Write settings to /run/squashmount:

sub write_settings {
	my $file = $rundir . "/$tag";
	my $fh;
	unless(open($fh, '>', $file)) {
		&error("cannot open $file for writing");
		return
	}
	for my $i (keys(%$current)) {
		my $value = $current->{$i};
		next unless(defined($value));
		my $write = "\$data\{\'$i\'\} = ";
		if($value eq '') {
			$write .= "''"
		} elsif($value =~ qr/^\-?\d*$/) {
			$write .= "$value"
		} else {
			$write .= '"' . quotemeta($value) . '"'
		}
		print($fh $write . ";\n") or &error("cannot write to $file")
	}
	close($fh)
}

# forget settings from /run/squashmount and mark that we will not save current

sub forget_settings {
	&info('forgetting settings') unless($quiet);
	$current->{'NOWRITE'} = 1;
	my $file = $rundir . "/$tag";
	return 1 unless(-f $file);
	unless(unlink($file)) {
		&error("unlinking $file failed: $!");
		return ''
	}
	return 1
}

# Fill "global" variables according to options and $current state

sub set_globals {
	if($opt_threshold ne '') {
		$threshold = &parse_threshold($opt_threshold)
	} else {
		$threshold = $current->{'THRESHOLD'}
	}
	if($threshold < 0) {
		$kill = ''
	} elsif(defined($opt_kill)) {
		$kill = $opt_kill
	} else {
		$kill = $current->{'KILL'}
	}
}

# Fill $current state with defaults from $user_config.

sub fill_current {
	my ($force) = @_;
	if($force || !exists($current->{'THRESHOLD'})) {
		$current->{'THRESHOLD'} = &parse_threshold($user_config->{'THRESHOLD'})
	}
	if($force || !exists($current->{'KILL'})) {
		$current->{'KILL'} = $user_config->{'KILL'}
	}
	return 1
}

# Turn argument into a number.

sub parse_threshold {
	my ($threshold) = @_;
	return 0 unless(defined($threshold));
	$threshold =~ s/[[:space:]]//g;
	$threshold =~ s/^\+//;
	return 0 unless($threshold =~ qr/^(\-?\d+)([kKmMgGtT])?$/);
	my ($num, $ext) = ($1, $2);
	return (-1) if($num < 0);
	return $num unless(defined($ext) && ($ext ne ''));
	return 1024 * $num if($ext =~ qr/[kK]/);
	return (1024 * 1024) * $num if($ext =~ qr/[mM]/);
	return (1024 * 1024 * 1024) * $num if($ext =~ qr/[gG]/);
	return (1024 * 1024 * 1024 * 1024) * $num # if($ext =~ qr/[tT]/);
}

# Turn argument into a human-readable string

sub human_threshold {
	my ($threshold) = @_;
	if($threshold > (512 * 1024 * 1024 * 1024)) {
		$threshold = &roundup($threshold, 1024 * 1024 * 1024 * 1024);
		return "${threshold}t"
	}
	if($threshold > (512 * 1024 * 1024)) {
		$threshold = &roundup($threshold, 1024 * 1024 * 1024);
		return "${threshold}g"
	}
	if($threshold > (512 * 1024)) {
		$threshold = &roundup($threshold, 1024 * 1024);
		return "${threshold}m"
	}
	if($threshold > 512) {
		$threshold = &roundup($threshold, 1024);
		return "${threshold}k"
	}
	return "$threshold"
}

# Return $a / $b rounded up

sub roundup {
	my ($a, $b) = @_;
	return (($a + $b - 1) / $b)
}

# Check whether passed configuration has a directory from $pass_directory

sub find_pass_directory {
	my ($hash, $pass_directory) = @_;
	for my $i (
		$hash->{'DIR'},
		$hash->{'CHANGES'},
		$hash->{'READONLY'}) {
		return 1 if(exists($pass_directory->{$i}))
	}
	return ''
}

# Initialize and create $current->{$i} from $user_config->{$i} if necessary
# Returns 1 on success -1 if directory is a nonempty non-path, '' otherwise

sub create_dir {
	my ($i, $require_dir) = @_;
	if(exists($current->{$i})) {
		return (&is_abspath($current->{$i}) ? 1 : -1)
	}
	my $dir = &create_dirname($user_config->{$i});
	unless(is_nonempty($dir)) {
		&error("failed to create $i");
		return ''
	}
	if(&is_abspath($dir)) {
		$current->{$i} = $dir;
		return 1
	}
	if($require_dir) {
		&error("no absolute directory $i");
		return ''
	}
	$current->{$i} = 1;
	return -1
}

# Fetch a filename from @CFG::mounts, creating the directory if necessary

sub create_dirname {
	my ($temp) = @_;
	$temp = '' unless(defined($temp));
	if(ref($temp) eq 'CODE') {
		$temp = &{$temp}($tag)
	}
	if(ref($temp) eq 'File::Temp::Dir') {
		$temp->unlink_on_destroy('');
		$temp = $temp->dirname;
	} elsif($temp eq '') {
		$temp = File::Temp::newdir(undef, CLEANUP => '');
		$temp = $temp->dirname;
	}
	return $temp unless(&is_abspath($temp));
	unless(-d $temp) {
		return undef unless &make_directory($temp);
	}
	return abs_path($temp)
}

# Return squashfile:

sub get_squashfile {
	if(exists($current->{'FILE'})) {
		return $current->{'FILE'}
	}
	return $user_config->{'FILE'}
}

# Test if argument is a valid type for resquashing:

sub is_resquash_type {
	my ($type) = @_;
	return '' unless(defined($type));
	return !(($type eq '') || ($type eq 'readonly') || ($type =~ qr/bind/))
}


# Check whether a directory tree is empty or reaches a threshold.
# Return value 1 means threshold is reached, -1 means nonempty but not reached.

{ # This block must occur before our actual function:
# "local arguments" to the "wanted" subfunction are kept in separate namespace:
	package process_dir;
	our $to_find; # We count from threshold downwards...
	our $found;   # Flag whether there is at least some data
	our $dir;
	our $skipfunc;
	our $skip;
	our $skipdir;
	our $check;
	our @compare; # Our memory for postponed file content comparison...
	our $blocksize;
}

sub threshold_dir {
	my ($threshold, $type) = @_;
	$process_dir::dir = $current->{'CHANGES'},;
	$process_dir::readonly = $current->{'READONLY'};
	$process_dir::to_find = $threshold;
	$process_dir::found = '';
	my $blocksize = $user_config->{'BLOCKSIZE'};
	$process_dir::blocksize = ((defined($blocksize) && ($blocksize > 0)) ?
					$blocksize : 4096 );
	$process_dir::skipfunc = $user_config->{'SKIPFUNC'};
	$process_dir::skip = $user_config->{'SKIP'};
	$process_dir::skipdir = $user_config->{'SKIPDIR'};
	$process_dir::check = $user_config->{'DIFF'};

	# Now some hidden files/directories for special filesystems:
	# We skip these files also if the $type does not match;
	# otherwise there would be confusion if e.g. changing from
	# aufs to overlayfs and thus suddenly aufs-hidden files are visible.
	# However, more exact would be to use the if clauses of the comments:
	push(@$process_dir::skip, qr/^\._funionfs/); # if($type eq 'funionfs')
	push(@$process_dir::skipdir, qr/^\.unionfs/);# if($type =~ qr/^unionfs/)
	push(@$process_dir::skip, qr/^\.wh\.\.wh\.aufs$/) &&
	push(@$process_dir::skipdir, qr/^\.wh\.\.wh\.((pli?nk)|(\.tmp)|orph)/);# if($type eq 'aufs')

	@process_dir::compare = ();
	find({
		no_chdir => 1,
		follow => '',
		follow_fast => 1,
		follow_skip => 2,
		dangling_symlinks => '',
		wanted => \&process_dir
	}, $process_dir::dir);
	return 1 if($process_dir::to_find < 0);
	# Only if the threshold is not reached we now do have to compare
	# also the content of files (see comments above file_is_equal):
	# If the files differ, they add to the threshold...
	for my $i (@process_dir::compare) {
		next if(compare($i->[0], $i->[1]) == 0);
		$process_dir::to_find -= $i->[2];
		if($process_dir::to_find < 0) {
			return 1
		}
		$process_dir::found = 1
	}
	return ($process_dir::found ? -1 : 0)
}

sub process_dir {
	if($process_dir::to_find < 0) {
		# Shortcut possible
		$File::Find::prune = 1;
		return
	}
	my $path = (substr($_, 0, length($process_dir::dir)) ne $process_dir::dir) ?
		$_ : substr($_, length($process_dir::dir));
	$path =~ s/^\///;
	return if(($path eq '') || &is_match($path, $process_dir::skip));
	if(&is_match($path, $process_dir::skipdir) && (-d $_) && !(-l $_)) {
		$File::Find::prune = 1;
		return
	}
	if(&is_match($path, $process_dir::check)) {
		return if &file_is_equal($_, $process_dir::readonly . "/$path")
	}
	if(defined($process_dir::skipfunc) && (ref($process_dir::skipfunc) eq 'CODE')) {
		local($_);
		return unless(&{$process_dir::skipfunc}($path, $_, $process_dir::readonly . "/$path"))
	}
	$process_dir::found = 1;
	my $size = (((-l $_) || !(-f $_)) ? 1 : (-s $_));
	$size = 1 if($size == 0);
	my $modulo = ($size % $process_dir::blocksize);
	$size += ($process_dir::blocksize - $modulo) if($modulo != 0);
	$process_dir::to_find -= $size;
	$File::Find::prune = 1 if($process_dir::to_find < 0)
}

# Check whether filetypes are equal.
# In case of files, postpone comparison by pushing into @process_dir::compare:
# We will compare the filecontent only if we did not reach the threshold
# in another way.

sub file_is_equal {
	my ($a, $b) = @_;
	if(-l $a) {
		return (-l $b);
	}
	return '' if(-l $b);
	if(-d $a) {
		return (-d $b)
	}
	if(-f $a) {
		if(-f $b) {
			my $size = (-s $a);
			return '' if($size ne (-s $b));
			push(@process_dir::compare, [ $a, $b, $size ]);
			return 1
		}
		return ''
	}
	return !(-f $b)
}

# Compare against an array of regular expressions

sub is_match {
	my($a, $reg) = @_;
	for my $r (@$reg) {
		return 1 if($a =~ $r)
	}
	return ''
}

# Make a directory with parents

sub make_directory {
	my ($dir) = @_;
	make_path($dir, { error => \my $err });
	return undef unless(&filepath_ok($err, 1))
}

# Clean all files from a directory

sub clean_directory {
	my ($dir) = @_;
	if($interactive) {
		print("Clean $dir? ");
		unless(<STDIN> =~ qr/^y/i) {
			&info("keeping $dir") if($verbose);
			return 1
		}
	}
	&info("cleaning $dir") if($verbose);
	remove_tree($dir, {
		keep_root => 1,
		error => \my $err
	});
	return &filepath_ok($err, '')
}

# Handle the error of make_path or remove_tree. Return true if no error

sub filepath_ok {
	my ($err, $make_path) = @_;
	return 1 unless(@$err);
	my $text = $make_path ? 'creating' : 'removing';
	for my $diag (@$err) {
		my ($file, $message) = %$diag;
		if($file eq '') {
			&error("(while $text): $message")
		} else {
			&error("(while $text $file): $message")
		}
	}
	return ''
}

# Output fatal error and die:

sub fatal {
	my @a = @_;
	&format(\@a, "$name: fatal: ");
	print(STDERR @a);
	exit(1)
}

# Output errors:

sub error {
	my @a = @_;
	&format(\@a, "$name: error:   ", 1);
	print(STDERR @a)
}

# Output warnings:

sub warning {
	my @a = @_;
	&format(\@a, "$name: warning: ", 1);
	print(@a)
}

# Output informal messages:

sub info {
	my @a = @_;
	&format(\@a, '', 1);
	print(@a)
}

# Format array for output:

sub format(\@$$) {
	my ($array, $label, $withtag) = @_;
	$withtag = '' unless(defined($withtag));
	$label = '' unless(defined($label));
	$label .= "\[$tag\]: " . (' ' x ($taglen - length($tag)))
		if($withtag && defined($tag) && ($tag ne ''));
	my $s = (' ' x length($label));
	grep($_ = "$s$_\n", @$array);
	$array->[0] =~ s/^$s/$label/ if($s ne '')
}

# Set title:

sub title {
	my ($a) = @_;
	return unless(defined($titleopt));
	my @opt = ();
	push(@opt, "\-$titleopt") if($titleopt ne '');
	if(system('title', @opt, '--', $a) == 0) {
		$printed_title = 1;
		return
	}
	$printed_title = '';
	$titleopt = undef
}

# If defined, print with $separator attached and return 1

sub do_print {
	my ($a) = @_;
	return '' unless(defined($a));
	$a .= $separator;
	print($a) if($a ne '');
	return 1
}

# The header of the print-* commands; only visible in verbose mode

sub print_header {
	print "\[$tag\]: " . ' ' x ($taglen - length($tag));
}

# Output for status command, respecting verbose modes

sub print_status_first {
	print $_[0]
}

sub print_status_end {
	print "\n"
}

sub print_status {
	my ($a) = @_;
	if($verbose) {
		print("\n" . (' ' x ($taglen + 4)) . $a);
	} else {
		print(", $a")
	}
}

# Is argument defined and nonempty?

sub is_nonempty {
	return (defined($_[0]) && ($_[0] ne ''))
}

# Is argument defined and an absolute path?

sub is_abspath {
	return (defined($_[0]) && (substr($_[0], 0, 1) eq '/'))
}

# compare two hashes

sub hash_equal {
	my ($a, $b) = @_;
	for my $i (keys(%$a)) {
		next unless(defined($a->{$i}));
		return '' unless(defined($b->{$i}));
		return '' unless($a->{$i} eq $b->{$i})
	}
	for my $i (keys(%$b)) {
		next unless(defined($b->{$i}));
		return '' unless(exists($a->{$i}))
	}
	return 1
}

# push string or reference to array of strings. If $s is undefined use $t

sub push_ref {
	my ($arr, $s, $t) = @_;
	$s = $t unless(defined($s));
	return unless(defined($s));
	if(ref($s) eq 'ARRAY') {
		push(@$arr, @$s);
		return
	}
	push(@$arr, $s) if($s ne '')
}

#
# Now the main program:
#

# Parse Options:

$Getopt::Long::bundling = 1;
GetOptions(
	'help|h', sub { pod2usage(1) },
	'man|?', sub { pod2usage(-verbose => 2) },
	'version|V', \&version,
	'config|c=s', \@configs,
	'rundir=s', \$rundir,
	'separator|S=s', \$separator,
	'interactice|i', \$interactive,
	'threshold|t=s', \$opt_threshold,
	'no-squash|nosquash|n', sub { $opt_threshold = '-1' },
	'squash|squash|s', sub { $opt_threshold = '0' },
	'kill|k', \$opt_kill,
	'no-kill|nokill|K', sub { $opt_kill = '' },
	'squash-verbose=i', \$squash_verbose,
	'lazy!', \$lazy,
	'force|f', \$force,
	'reset|r', \$reset,
	'pass-directory', \$pass_directory,
	'title|T=s', \@title,
	'error|e', \$errorbreak,
	'no-error|noerror|E', sub { $errorbreak = '' },
	'first|1', \$firstmatch,
	'verbose|v+', \$verbose,
	'quiet|q+', \$quiet
) or pod2usage(2);

# Check options:

&fatal("$rundir is not an absolute path") unless(&is_abspath($rundir));
for my $i (@configs) {
	&fatal("config-file $i is not an absolute path") unless(&is_abspath($rundir))
}

# Postprocess options:

@configs = ('/etc/squashmount.pl') unless(@configs);
if($quiet < $verbose) {
	$verbose -= $quiet; $quiet = 0
} else {
	$quiet -= $verbose; $verbose = 0
}
$titleopt = join('', @title);
undef(@title);
$titleopt = undef if(($titleopt =~ qr/-/) || !(-t STDOUT));

# Determine action:

my $action = shift(@ARGV);
$action = '' unless(defined($action));
if($action =~ /^p/i) {
	if($action =~ /tag/i) {
		$action = \&cmd_print_tag
	} elsif($action =~ /dir/i) {
		$action = \&cmd_print_dir
	} elsif($action =~ /chan/i) {
		$action = \&cmd_print_changes
	} elsif($action =~ /read|ro/i) {
		$action = \&cmd_print_readonly
	} elsif($action =~ /fil/i) {
		$action = \&cmd_print_file
	} elsif($action =~ /typ/i) {
		$action = \&cmd_print_type
	} elsif($action =~ /new|mod/i) {
		$action = \&cmd_print_new
	} elsif($action =~ /will|sq|comp/i) {
		$action = \&cmd_print_will_squash
	} elsif($action =~ /thr/i) {
		$action = \&cmd_print_threshold
	} elsif($action =~ /kil/i) {
		$action = \&cmd_print_kill
	}
} elsif($action =~ /^(stat|l)/i) {
	$action = \&cmd_status
} elsif($action =~ /^mo/i) {
	$action = \&cmd_mount
} elsif($action =~ /^star/i) {
	$action = \&cmd_start
} elsif($action =~ /^cr/i) {
	$action = \&cmd_create
} elsif($action =~ /set/i) {
	if($action =~ /[ur]/i) {
		$action = \&cmd_reset
	} else {
		$action = \&cmd_set
	}
} elsif($action =~ /^u/i) {
	$action = \&cmd_umount
} elsif($action =~ /^sto/i) {
	$action = \&cmd_stop
} elsif($action =~ /^rem/i) {
	$action = \&cmd_remount
} elsif($action =~ /^rest/i) {
	$action = \&cmd_restart
} elsif($action =~ /^for/i) {
	$action = \&cmd_forget
} elsif($action =~ /^m/i) {
	pod2usage(-verbose => 2)
} elsif($action =~ /^h|\?/i) {
	pod2usage(0)
}
pod2usage(2) unless(ref($action) eq 'CODE');

# Read config files:

for my $file (@configs) {
	&read_config_file($file)
}

# Modify options according to config:

$squash_verbose = $CFG::squash_verbose unless(defined($squash_verbose));
$lazy = $CFG::lazy unless(defined($lazy));


# Fill the %tags array in the appropriate order.
# As a side result calculate $taglen.

my %tags = ();
$taglen = 0;
for(my $i = 0; $i < @CFG::mounts; ++$i) {
	my $mount = $CFG::mounts[$i];
	&fatal('config error: element ' . ($i + 1) . 'of @mounts is not a hash')
		unless(ref($mount) eq 'HASH');
	my $tag = $mount->{'TAG'};
	&fatal('config error: mount-point ' . ($i + 1) . ' has no TAG')
		unless(&is_nonempty($tag));
	&fatal("config error: $tag not alphanumeric")
		if($tag =~ qr/[^a-zA-Z\d_.\-]/);
	&fatal("config error: $tag duplicate in mount-points" .
		($tags{$tag} + 1) . ' and ' . ($i + 1)) if(exists($tags{$tag}));
	$tags{$tag} = $i;
	$taglen = length($tag) if(length($tag) > $taglen);
	&fatal("config error: $tag has no absolute FILE specified")
		unless(&is_abspath($mount->{'FILE'}));
	my $dir = $mount->{'DIR'};
	&fatal("config error: $tag has no absolute DIR specified")
		unless(defined($dir) && ((ref($dir) eq 'CODE')
			|| &is_abspath($dir)));
	# Compile all regular expressions and transform into arrays:
	for my $j ('SKIP', 'SKIPDIR', 'DIFF') {
		my $a = $mount->{$j};
		unless(defined($a)) {
			$mount->{$j} = [];
			next
		}
		if(ref($a) ne 'ARRAY') {
			if(defined($a) && ($a ne '')) {
				$mount->{$j} = [ qr/$a/ ];
				next
			}
			$mount->{$j} = [];
			next
		}
		for my $r (@$a) {
			$r = qr/$r/
		}
	}
}

# Now fill @mounts or %pass_directory, respectively, according to masks:

my @mounts = ();
my %pass_directory = ();

if($pass_directory) {
	for my $i (@ARGV) {
		$pass_directory{$i} = 1 if(&is_abspath($i));
		my $j = abs_path($i);
		$pass_directory{$j} = 1 if(&is_abspath($j))
	}
} else {
	if(@ARGV) {
		for my $i (@ARGV) {
			$i =~ s/([^\w\*\?\[\]])/\\$1/g;
			$i =~ s/\*/.*/g;
			$i =~ s/\?/./g;
			my $reg = qr/^$i$/;
			for my $j (@CFG::mounts) {
				next unless($j->{'TAG'} =~ $reg);
				next if(exists($j->{'DONE'}));
				push(@mounts, $j);
				$j->{'DONE'} = 1
			}
		}
	} else {
		@mounts = @CFG::mounts
	}
	unless(@mounts) {
		&warning('no mount-points selected') unless($quiet);
		exit
	}
}

# Make sure our runtime is reasonable:

&make_directory($rundir) unless(-d $rundir);

# Finally the main loop over the @mounts or %pass_directory entries:

my $exitstatus = 0;
for my $i ($pass_directory ? (@CFG::mounts) : (@mounts)) {
	$user_config = $i;
	$tag = $i->{'TAG'};
	my %current;
	$current = \%current;
	&read_settings();
	if($pass_directory) {
		next unless(&find_pass_directory($current, \%pass_directory)
			|| &find_pass_directory($user_config, \%pass_directory))
	}
	my %current_bak = %current;
	&fill_current('');
	&set_globals();
	unless(&{$action}()) {
		$exitstatus = 1 if($exitstatus == 0)
	}
	my $nowrite = $current{'NOWRITE'};
	$nowrite = '' unless(defined($nowrite));
	&write_settings() unless($nowrite || &hash_equal(\%current_bak, $current));
	last if(($firstmatch) || ($errorbreak && ($exitstatus != 0)))
}
exit($exitstatus);

END {
	&title(($? == 0) ? "$name finished" : "$name failed")
		if(defined($printed_title) && $printed_title)
}
